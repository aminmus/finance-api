### This file was generated by Nexus Schema
### Do not make changes to this file directly


type Asset {
  createdAt: DateTime!
  description: String
  id: Int!
  name: String!
  portfolioId: Int!
  quantity: Int!
  updatedAt: DateTime!
}

input AssetCreateNestedManyWithoutPortfolioInput {
  connect: [AssetWhereUniqueInput!]
  connectOrCreate: [AssetCreateOrConnectWithoutPortfolioInput!]
  create: [AssetCreateWithoutPortfolioInput!]
}

input AssetCreateNestedOneWithoutPrivateAssetInput {
  connect: AssetWhereUniqueInput
  connectOrCreate: AssetCreateOrConnectWithoutPrivateAssetInput
  create: AssetCreateWithoutPrivateAssetInput
}

input AssetCreateNestedOneWithoutPublicAssetInput {
  connect: AssetWhereUniqueInput
  connectOrCreate: AssetCreateOrConnectWithoutPublicAssetInput
  create: AssetCreateWithoutPublicAssetInput
}

input AssetCreateOrConnectWithoutPortfolioInput {
  create: AssetCreateWithoutPortfolioInput!
  where: AssetWhereUniqueInput!
}

input AssetCreateOrConnectWithoutPrivateAssetInput {
  create: AssetCreateWithoutPrivateAssetInput!
  where: AssetWhereUniqueInput!
}

input AssetCreateOrConnectWithoutPublicAssetInput {
  create: AssetCreateWithoutPublicAssetInput!
  where: AssetWhereUniqueInput!
}

input AssetCreateWithoutPortfolioInput {
  createdAt: DateTime
  description: String
  name: String!
  privateAsset: PrivateAssetCreateNestedOneWithoutBaseAssetInput
  publicAsset: PublicAssetCreateNestedOneWithoutBaseAssetInput
  quantity: Int
  transactions: TransactionRecordCreateNestedManyWithoutAssetInput
  updatedAt: DateTime
}

input AssetCreateWithoutPrivateAssetInput {
  createdAt: DateTime
  description: String
  name: String!
  portfolio: PortfolioCreateNestedOneWithoutAssetsInput!
  publicAsset: PublicAssetCreateNestedOneWithoutBaseAssetInput
  quantity: Int
  transactions: TransactionRecordCreateNestedManyWithoutAssetInput
  updatedAt: DateTime
}

input AssetCreateWithoutPublicAssetInput {
  createdAt: DateTime
  description: String
  name: String!
  portfolio: PortfolioCreateNestedOneWithoutAssetsInput!
  privateAsset: PrivateAssetCreateNestedOneWithoutBaseAssetInput
  quantity: Int
  transactions: TransactionRecordCreateNestedManyWithoutAssetInput
  updatedAt: DateTime
}

input AssetScalarWhereInput {
  AND: [AssetScalarWhereInput!]
  NOT: [AssetScalarWhereInput!]
  OR: [AssetScalarWhereInput!]
  createdAt: DateTimeFilter
  description: StringNullableFilter
  id: IntFilter
  name: StringFilter
  portfolioId: IntFilter
  quantity: IntFilter
  updatedAt: DateTimeFilter
}

input AssetUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  quantity: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input AssetUpdateManyWithWhereWithoutPortfolioInput {
  data: AssetUpdateManyMutationInput!
  where: AssetScalarWhereInput!
}

input AssetUpdateManyWithoutPortfolioInput {
  connect: [AssetWhereUniqueInput!]
  connectOrCreate: [AssetCreateOrConnectWithoutPortfolioInput!]
  create: [AssetCreateWithoutPortfolioInput!]
  delete: [AssetWhereUniqueInput!]
  deleteMany: [AssetScalarWhereInput!]
  disconnect: [AssetWhereUniqueInput!]
  set: [AssetWhereUniqueInput!]
  update: [AssetUpdateWithWhereUniqueWithoutPortfolioInput!]
  updateMany: [AssetUpdateManyWithWhereWithoutPortfolioInput!]
  upsert: [AssetUpsertWithWhereUniqueWithoutPortfolioInput!]
}

input AssetUpdateOneRequiredWithoutPrivateAssetInput {
  connect: AssetWhereUniqueInput
  connectOrCreate: AssetCreateOrConnectWithoutPrivateAssetInput
  create: AssetCreateWithoutPrivateAssetInput
  update: AssetUpdateWithoutPrivateAssetInput
  upsert: AssetUpsertWithoutPrivateAssetInput
}

input AssetUpdateOneRequiredWithoutPublicAssetInput {
  connect: AssetWhereUniqueInput
  connectOrCreate: AssetCreateOrConnectWithoutPublicAssetInput
  create: AssetCreateWithoutPublicAssetInput
  update: AssetUpdateWithoutPublicAssetInput
  upsert: AssetUpsertWithoutPublicAssetInput
}

input AssetUpdateWithWhereUniqueWithoutPortfolioInput {
  data: AssetUpdateWithoutPortfolioInput!
  where: AssetWhereUniqueInput!
}

input AssetUpdateWithoutPortfolioInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  privateAsset: PrivateAssetUpdateOneWithoutBaseAssetInput
  publicAsset: PublicAssetUpdateOneWithoutBaseAssetInput
  quantity: IntFieldUpdateOperationsInput
  transactions: TransactionRecordUpdateManyWithoutAssetInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input AssetUpdateWithoutPrivateAssetInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  portfolio: PortfolioUpdateOneRequiredWithoutAssetsInput
  publicAsset: PublicAssetUpdateOneWithoutBaseAssetInput
  quantity: IntFieldUpdateOperationsInput
  transactions: TransactionRecordUpdateManyWithoutAssetInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input AssetUpdateWithoutPublicAssetInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  portfolio: PortfolioUpdateOneRequiredWithoutAssetsInput
  privateAsset: PrivateAssetUpdateOneWithoutBaseAssetInput
  quantity: IntFieldUpdateOperationsInput
  transactions: TransactionRecordUpdateManyWithoutAssetInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input AssetUpsertWithWhereUniqueWithoutPortfolioInput {
  create: AssetCreateWithoutPortfolioInput!
  update: AssetUpdateWithoutPortfolioInput!
  where: AssetWhereUniqueInput!
}

input AssetUpsertWithoutPrivateAssetInput {
  create: AssetCreateWithoutPrivateAssetInput!
  update: AssetUpdateWithoutPrivateAssetInput!
}

input AssetUpsertWithoutPublicAssetInput {
  create: AssetCreateWithoutPublicAssetInput!
  update: AssetUpdateWithoutPublicAssetInput!
}

input AssetWhereUniqueInput {
  id: Int
}

type AuthPayload {
  token: String!
  user: User!
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input EnumTransactionTypeFieldUpdateOperationsInput {
  set: TransactionType
}

input EnumTransactionTypeFilter {
  equals: TransactionType
  in: [TransactionType!]
  not: NestedEnumTransactionTypeFilter
  notIn: [TransactionType!]
}

type HistoricalValue {
  assetId: Int!
  createdAt: DateTime!
  date: DateTime!
  id: Int!
  unitPrice: Int!
  updatedAt: DateTime!
}

input HistoricalValueCreateInput {
  asset: PrivateAssetCreateNestedOneWithoutHistoricalValuesInput!
  createdAt: DateTime
  date: DateTime
  unitPrice: Int!
  updatedAt: DateTime
}

input HistoricalValueCreateNestedManyWithoutAssetInput {
  connect: [HistoricalValueWhereUniqueInput!]
  connectOrCreate: [HistoricalValueCreateOrConnectWithoutAssetInput!]
  create: [HistoricalValueCreateWithoutAssetInput!]
}

input HistoricalValueCreateOrConnectWithoutAssetInput {
  create: HistoricalValueCreateWithoutAssetInput!
  where: HistoricalValueWhereUniqueInput!
}

input HistoricalValueCreateWithoutAssetInput {
  createdAt: DateTime
  date: DateTime
  unitPrice: Int!
  updatedAt: DateTime
}

input HistoricalValueScalarWhereInput {
  AND: [HistoricalValueScalarWhereInput!]
  NOT: [HistoricalValueScalarWhereInput!]
  OR: [HistoricalValueScalarWhereInput!]
  assetId: IntFilter
  createdAt: DateTimeFilter
  date: DateTimeFilter
  id: IntFilter
  unitPrice: IntFilter
  updatedAt: DateTimeFilter
}

input HistoricalValueUpdateInput {
  asset: PrivateAssetUpdateOneRequiredWithoutHistoricalValuesInput
  createdAt: DateTimeFieldUpdateOperationsInput
  date: DateTimeFieldUpdateOperationsInput
  unitPrice: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input HistoricalValueUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  date: DateTimeFieldUpdateOperationsInput
  unitPrice: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input HistoricalValueUpdateManyWithWhereWithoutAssetInput {
  data: HistoricalValueUpdateManyMutationInput!
  where: HistoricalValueScalarWhereInput!
}

input HistoricalValueUpdateManyWithoutAssetInput {
  connect: [HistoricalValueWhereUniqueInput!]
  connectOrCreate: [HistoricalValueCreateOrConnectWithoutAssetInput!]
  create: [HistoricalValueCreateWithoutAssetInput!]
  delete: [HistoricalValueWhereUniqueInput!]
  deleteMany: [HistoricalValueScalarWhereInput!]
  disconnect: [HistoricalValueWhereUniqueInput!]
  set: [HistoricalValueWhereUniqueInput!]
  update: [HistoricalValueUpdateWithWhereUniqueWithoutAssetInput!]
  updateMany: [HistoricalValueUpdateManyWithWhereWithoutAssetInput!]
  upsert: [HistoricalValueUpsertWithWhereUniqueWithoutAssetInput!]
}

input HistoricalValueUpdateWithWhereUniqueWithoutAssetInput {
  data: HistoricalValueUpdateWithoutAssetInput!
  where: HistoricalValueWhereUniqueInput!
}

input HistoricalValueUpdateWithoutAssetInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  date: DateTimeFieldUpdateOperationsInput
  unitPrice: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input HistoricalValueUpsertWithWhereUniqueWithoutAssetInput {
  create: HistoricalValueCreateWithoutAssetInput!
  update: HistoricalValueUpdateWithoutAssetInput!
  where: HistoricalValueWhereUniqueInput!
}

input HistoricalValueWhereUniqueInput {
  id: Int
}

input IntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

type Mutation {
  createOneHistoricalValue(data: HistoricalValueCreateInput!): HistoricalValue!
  createOnePortfolio(data: PortfolioCreateInput!): Portfolio!
  createOnePrivateAsset(data: PrivateAssetCreateInput!): PrivateAsset!
  createOnePublicAsset(data: PublicAssetCreateInput!): PublicAsset!
  createOneUser(data: UserCreateInput!): User!
  deleteOneHistoricalValue(where: HistoricalValueWhereUniqueInput!): HistoricalValue
  deleteOnePortfolio(where: PortfolioWhereUniqueInput!): Portfolio
  deleteOnePrivateAsset(where: PrivateAssetWhereUniqueInput!): PrivateAsset
  deleteOnePublicAsset(where: PublicAssetWhereUniqueInput!): PublicAsset
  deleteOneUser(where: UserWhereUniqueInput!): User
  login(email: String!, password: String!): AuthPayload
  makeTransaction(data: TransactionCreateInput!): Transaction!
  updateOneHistoricalValue(data: HistoricalValueUpdateInput!, where: HistoricalValueWhereUniqueInput!): HistoricalValue
  updateOnePortfolio(data: PortfolioUpdateInput!, where: PortfolioWhereUniqueInput!): Portfolio
  updateOnePrivateAsset(data: PrivateAssetUpdateInput!, where: PrivateAssetWhereUniqueInput!): PrivateAsset
  updateOnePublicAsset(data: PublicAssetUpdateInput!, where: PublicAssetWhereUniqueInput!): PublicAsset
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedEnumTransactionTypeFilter {
  equals: TransactionType
  in: [TransactionType!]
  not: NestedEnumTransactionTypeFilter
  notIn: [TransactionType!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type Portfolio {
  assets(after: AssetWhereUniqueInput, before: AssetWhereUniqueInput, first: Int, last: Int): [Asset!]!
  createdAt: DateTime!
  description: String
  id: Int!
  name: String!
  owner: User!
  updatedAt: DateTime!
}

input PortfolioCreateInput {
  assets: AssetCreateNestedManyWithoutPortfolioInput
  createdAt: DateTime
  description: String
  name: String!
  owner: UserCreateNestedOneWithoutPortfoliosInput!
  updatedAt: DateTime
}

input PortfolioCreateNestedManyWithoutOwnerInput {
  connect: [PortfolioWhereUniqueInput!]
  connectOrCreate: [PortfolioCreateOrConnectWithoutOwnerInput!]
  create: [PortfolioCreateWithoutOwnerInput!]
}

input PortfolioCreateNestedOneWithoutAssetsInput {
  connect: PortfolioWhereUniqueInput
  connectOrCreate: PortfolioCreateOrConnectWithoutAssetsInput
  create: PortfolioCreateWithoutAssetsInput
}

input PortfolioCreateOrConnectWithoutAssetsInput {
  create: PortfolioCreateWithoutAssetsInput!
  where: PortfolioWhereUniqueInput!
}

input PortfolioCreateOrConnectWithoutOwnerInput {
  create: PortfolioCreateWithoutOwnerInput!
  where: PortfolioWhereUniqueInput!
}

input PortfolioCreateWithoutAssetsInput {
  createdAt: DateTime
  description: String
  name: String!
  owner: UserCreateNestedOneWithoutPortfoliosInput!
  updatedAt: DateTime
}

input PortfolioCreateWithoutOwnerInput {
  assets: AssetCreateNestedManyWithoutPortfolioInput
  createdAt: DateTime
  description: String
  name: String!
  updatedAt: DateTime
}

input PortfolioScalarWhereInput {
  AND: [PortfolioScalarWhereInput!]
  NOT: [PortfolioScalarWhereInput!]
  OR: [PortfolioScalarWhereInput!]
  createdAt: DateTimeFilter
  description: StringNullableFilter
  id: IntFilter
  name: StringFilter
  updatedAt: DateTimeFilter
  userId: IntFilter
}

input PortfolioUpdateInput {
  assets: AssetUpdateManyWithoutPortfolioInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  owner: UserUpdateOneRequiredWithoutPortfoliosInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input PortfolioUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input PortfolioUpdateManyWithWhereWithoutOwnerInput {
  data: PortfolioUpdateManyMutationInput!
  where: PortfolioScalarWhereInput!
}

input PortfolioUpdateManyWithoutOwnerInput {
  connect: [PortfolioWhereUniqueInput!]
  connectOrCreate: [PortfolioCreateOrConnectWithoutOwnerInput!]
  create: [PortfolioCreateWithoutOwnerInput!]
  delete: [PortfolioWhereUniqueInput!]
  deleteMany: [PortfolioScalarWhereInput!]
  disconnect: [PortfolioWhereUniqueInput!]
  set: [PortfolioWhereUniqueInput!]
  update: [PortfolioUpdateWithWhereUniqueWithoutOwnerInput!]
  updateMany: [PortfolioUpdateManyWithWhereWithoutOwnerInput!]
  upsert: [PortfolioUpsertWithWhereUniqueWithoutOwnerInput!]
}

input PortfolioUpdateOneRequiredWithoutAssetsInput {
  connect: PortfolioWhereUniqueInput
  connectOrCreate: PortfolioCreateOrConnectWithoutAssetsInput
  create: PortfolioCreateWithoutAssetsInput
  update: PortfolioUpdateWithoutAssetsInput
  upsert: PortfolioUpsertWithoutAssetsInput
}

input PortfolioUpdateWithWhereUniqueWithoutOwnerInput {
  data: PortfolioUpdateWithoutOwnerInput!
  where: PortfolioWhereUniqueInput!
}

input PortfolioUpdateWithoutAssetsInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  owner: UserUpdateOneRequiredWithoutPortfoliosInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input PortfolioUpdateWithoutOwnerInput {
  assets: AssetUpdateManyWithoutPortfolioInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input PortfolioUpsertWithWhereUniqueWithoutOwnerInput {
  create: PortfolioCreateWithoutOwnerInput!
  update: PortfolioUpdateWithoutOwnerInput!
  where: PortfolioWhereUniqueInput!
}

input PortfolioUpsertWithoutAssetsInput {
  create: PortfolioCreateWithoutAssetsInput!
  update: PortfolioUpdateWithoutAssetsInput!
}

input PortfolioWhereUniqueInput {
  id: Int
}

"""
Privately traded asset. For assets that are not traded on a supported public market.
"""
type PrivateAsset {
  baseAsset: Asset!
  historicalValues(after: HistoricalValueWhereUniqueInput, before: HistoricalValueWhereUniqueInput, first: Int, last: Int): [HistoricalValue!]!
  id: Int!
}

input PrivateAssetCreateInput {
  baseAsset: AssetCreateNestedOneWithoutPrivateAssetInput!
  historicalValues: HistoricalValueCreateNestedManyWithoutAssetInput
}

input PrivateAssetCreateNestedOneWithoutBaseAssetInput {
  connect: PrivateAssetWhereUniqueInput
  connectOrCreate: PrivateAssetCreateOrConnectWithoutBaseAssetInput
  create: PrivateAssetCreateWithoutBaseAssetInput
}

input PrivateAssetCreateNestedOneWithoutHistoricalValuesInput {
  connect: PrivateAssetWhereUniqueInput
  connectOrCreate: PrivateAssetCreateOrConnectWithoutHistoricalValuesInput
  create: PrivateAssetCreateWithoutHistoricalValuesInput
}

input PrivateAssetCreateOrConnectWithoutBaseAssetInput {
  create: PrivateAssetCreateWithoutBaseAssetInput!
  where: PrivateAssetWhereUniqueInput!
}

input PrivateAssetCreateOrConnectWithoutHistoricalValuesInput {
  create: PrivateAssetCreateWithoutHistoricalValuesInput!
  where: PrivateAssetWhereUniqueInput!
}

input PrivateAssetCreateWithoutBaseAssetInput {
  historicalValues: HistoricalValueCreateNestedManyWithoutAssetInput
}

input PrivateAssetCreateWithoutHistoricalValuesInput {
  baseAsset: AssetCreateNestedOneWithoutPrivateAssetInput!
}

input PrivateAssetUpdateInput {
  baseAsset: AssetUpdateOneRequiredWithoutPrivateAssetInput
  historicalValues: HistoricalValueUpdateManyWithoutAssetInput
}

input PrivateAssetUpdateOneRequiredWithoutHistoricalValuesInput {
  connect: PrivateAssetWhereUniqueInput
  connectOrCreate: PrivateAssetCreateOrConnectWithoutHistoricalValuesInput
  create: PrivateAssetCreateWithoutHistoricalValuesInput
  update: PrivateAssetUpdateWithoutHistoricalValuesInput
  upsert: PrivateAssetUpsertWithoutHistoricalValuesInput
}

input PrivateAssetUpdateOneWithoutBaseAssetInput {
  connect: PrivateAssetWhereUniqueInput
  connectOrCreate: PrivateAssetCreateOrConnectWithoutBaseAssetInput
  create: PrivateAssetCreateWithoutBaseAssetInput
  delete: Boolean
  disconnect: Boolean
  update: PrivateAssetUpdateWithoutBaseAssetInput
  upsert: PrivateAssetUpsertWithoutBaseAssetInput
}

input PrivateAssetUpdateWithoutBaseAssetInput {
  historicalValues: HistoricalValueUpdateManyWithoutAssetInput
}

input PrivateAssetUpdateWithoutHistoricalValuesInput {
  baseAsset: AssetUpdateOneRequiredWithoutPrivateAssetInput
}

input PrivateAssetUpsertWithoutBaseAssetInput {
  create: PrivateAssetCreateWithoutBaseAssetInput!
  update: PrivateAssetUpdateWithoutBaseAssetInput!
}

input PrivateAssetUpsertWithoutHistoricalValuesInput {
  create: PrivateAssetCreateWithoutHistoricalValuesInput!
  update: PrivateAssetUpdateWithoutHistoricalValuesInput!
}

input PrivateAssetWhereUniqueInput {
  id: Int
}

"""
Publicly traded asset. For assets that are traded in a known and supported public market.
"""
type PublicAsset {
  baseAsset: Asset!
  id: Int!
  market: String
  symbol: String
}

input PublicAssetCreateInput {
  baseAsset: AssetCreateNestedOneWithoutPublicAssetInput!
  market: String
  symbol: String
}

input PublicAssetCreateNestedOneWithoutBaseAssetInput {
  connect: PublicAssetWhereUniqueInput
  connectOrCreate: PublicAssetCreateOrConnectWithoutBaseAssetInput
  create: PublicAssetCreateWithoutBaseAssetInput
}

input PublicAssetCreateOrConnectWithoutBaseAssetInput {
  create: PublicAssetCreateWithoutBaseAssetInput!
  where: PublicAssetWhereUniqueInput!
}

input PublicAssetCreateWithoutBaseAssetInput {
  market: String
  symbol: String
}

input PublicAssetUpdateInput {
  baseAsset: AssetUpdateOneRequiredWithoutPublicAssetInput
  market: NullableStringFieldUpdateOperationsInput
  symbol: NullableStringFieldUpdateOperationsInput
}

input PublicAssetUpdateOneWithoutBaseAssetInput {
  connect: PublicAssetWhereUniqueInput
  connectOrCreate: PublicAssetCreateOrConnectWithoutBaseAssetInput
  create: PublicAssetCreateWithoutBaseAssetInput
  delete: Boolean
  disconnect: Boolean
  update: PublicAssetUpdateWithoutBaseAssetInput
  upsert: PublicAssetUpsertWithoutBaseAssetInput
}

input PublicAssetUpdateWithoutBaseAssetInput {
  market: NullableStringFieldUpdateOperationsInput
  symbol: NullableStringFieldUpdateOperationsInput
}

input PublicAssetUpsertWithoutBaseAssetInput {
  create: PublicAssetCreateWithoutBaseAssetInput!
  update: PublicAssetUpdateWithoutBaseAssetInput!
}

input PublicAssetWhereUniqueInput {
  id: Int
}

type Query {
  myUser: User
  portfolio(where: PortfolioWhereUniqueInput!): Portfolio
  portfolios(after: PortfolioWhereUniqueInput, before: PortfolioWhereUniqueInput, first: Int, last: Int): [Portfolio!]!
  privateAsset(where: PrivateAssetWhereUniqueInput!): PrivateAsset
  privateAssets(after: PrivateAssetWhereUniqueInput, before: PrivateAssetWhereUniqueInput, first: Int, last: Int): [PrivateAsset!]!
  publicAsset(where: PublicAssetWhereUniqueInput!): PublicAsset
  publicAssets(after: PublicAssetWhereUniqueInput, before: PublicAssetWhereUniqueInput, first: Int, last: Int): [PublicAsset!]!
}

enum QueryMode {
  default
  insensitive
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

type Transaction {
  assetId: Int!
  assetQuantity: Int!
  createdAt: DateTime!
  currency: String!
  date: DateTime!
  id: Int!
  note: String
  totalPrice: Int!
  transactionType: TransactionType!
  unitPrice: Int!
  updatedAt: DateTime!
}

input TransactionCreateInput {
  assetId: Int!
  assetQuantity: Int!
  currency: String!
  note: String
  transactionType: TransactionType!
  unitPrice: Int!
}

input TransactionRecordCreateNestedManyWithoutAssetInput {
  connect: [TransactionRecordWhereUniqueInput!]
  connectOrCreate: [TransactionRecordCreateOrConnectWithoutAssetInput!]
  create: [TransactionRecordCreateWithoutAssetInput!]
}

input TransactionRecordCreateOrConnectWithoutAssetInput {
  create: TransactionRecordCreateWithoutAssetInput!
  where: TransactionRecordWhereUniqueInput!
}

input TransactionRecordCreateWithoutAssetInput {
  assetQuantity: Int!
  createdAt: DateTime
  currency: String!
  date: DateTime
  note: String
  transactionType: TransactionType!
  unitPrice: Int!
  updatedAt: DateTime
}

input TransactionRecordScalarWhereInput {
  AND: [TransactionRecordScalarWhereInput!]
  NOT: [TransactionRecordScalarWhereInput!]
  OR: [TransactionRecordScalarWhereInput!]
  assetId: IntFilter
  assetQuantity: IntFilter
  createdAt: DateTimeFilter
  currency: StringFilter
  date: DateTimeFilter
  id: IntFilter
  note: StringNullableFilter
  transactionType: EnumTransactionTypeFilter
  unitPrice: IntFilter
  updatedAt: DateTimeFilter
}

input TransactionRecordUpdateManyMutationInput {
  assetQuantity: IntFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  currency: StringFieldUpdateOperationsInput
  date: DateTimeFieldUpdateOperationsInput
  note: NullableStringFieldUpdateOperationsInput
  transactionType: EnumTransactionTypeFieldUpdateOperationsInput
  unitPrice: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input TransactionRecordUpdateManyWithWhereWithoutAssetInput {
  data: TransactionRecordUpdateManyMutationInput!
  where: TransactionRecordScalarWhereInput!
}

input TransactionRecordUpdateManyWithoutAssetInput {
  connect: [TransactionRecordWhereUniqueInput!]
  connectOrCreate: [TransactionRecordCreateOrConnectWithoutAssetInput!]
  create: [TransactionRecordCreateWithoutAssetInput!]
  delete: [TransactionRecordWhereUniqueInput!]
  deleteMany: [TransactionRecordScalarWhereInput!]
  disconnect: [TransactionRecordWhereUniqueInput!]
  set: [TransactionRecordWhereUniqueInput!]
  update: [TransactionRecordUpdateWithWhereUniqueWithoutAssetInput!]
  updateMany: [TransactionRecordUpdateManyWithWhereWithoutAssetInput!]
  upsert: [TransactionRecordUpsertWithWhereUniqueWithoutAssetInput!]
}

input TransactionRecordUpdateWithWhereUniqueWithoutAssetInput {
  data: TransactionRecordUpdateWithoutAssetInput!
  where: TransactionRecordWhereUniqueInput!
}

input TransactionRecordUpdateWithoutAssetInput {
  assetQuantity: IntFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  currency: StringFieldUpdateOperationsInput
  date: DateTimeFieldUpdateOperationsInput
  note: NullableStringFieldUpdateOperationsInput
  transactionType: EnumTransactionTypeFieldUpdateOperationsInput
  unitPrice: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input TransactionRecordUpsertWithWhereUniqueWithoutAssetInput {
  create: TransactionRecordCreateWithoutAssetInput!
  update: TransactionRecordUpdateWithoutAssetInput!
  where: TransactionRecordWhereUniqueInput!
}

input TransactionRecordWhereUniqueInput {
  id: Int
}

enum TransactionType {
  buy
  sell
}

type User {
  createdAt: DateTime!
  email: String!
  id: Int!
  name: String!
  updatedAt: DateTime!
}

input UserCreateInput {
  createdAt: DateTime
  email: String!
  name: String!
  password: String!
  portfolios: PortfolioCreateNestedManyWithoutOwnerInput
  updatedAt: DateTime
}

input UserCreateNestedOneWithoutPortfoliosInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutPortfoliosInput
  create: UserCreateWithoutPortfoliosInput
}

input UserCreateOrConnectWithoutPortfoliosInput {
  create: UserCreateWithoutPortfoliosInput!
  where: UserWhereUniqueInput!
}

input UserCreateWithoutPortfoliosInput {
  createdAt: DateTime
  email: String!
  name: String!
  password: String!
  updatedAt: DateTime
}

input UserUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  portfolios: PortfolioUpdateManyWithoutOwnerInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateOneRequiredWithoutPortfoliosInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutPortfoliosInput
  create: UserCreateWithoutPortfoliosInput
  update: UserUpdateWithoutPortfoliosInput
  upsert: UserUpsertWithoutPortfoliosInput
}

input UserUpdateWithoutPortfoliosInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpsertWithoutPortfoliosInput {
  create: UserCreateWithoutPortfoliosInput!
  update: UserUpdateWithoutPortfoliosInput!
}

input UserWhereUniqueInput {
  email: String
  id: Int
}
