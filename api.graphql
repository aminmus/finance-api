### This file was generated by Nexus Schema
### Do not make changes to this file directly


type Asset {
  createdAt: DateTime!
  description: String
  id: Int!
  name: String!
  portfolioId: Int!
  quantity: Int!
  ticker: String
  updatedAt: DateTime!
}

input AssetCreateInput {
  createdAt: DateTime
  CustomAsset: CustomAssetCreateOneWithoutAssetInput
  description: String
  name: String!
  Portfolio: PortfolioCreateOneWithoutAssetsInput!
  ticker: String
  Transaction: TransactionCreateManyWithoutAssetInput
  updatedAt: DateTime
}

input AssetCreateManyWithoutPortfolioInput {
  connect: [AssetWhereUniqueInput!]
  create: [AssetCreateWithoutPortfolioInput!]
}

input AssetCreateOneWithoutTransactionInput {
  connect: AssetWhereUniqueInput
  create: AssetCreateWithoutTransactionInput
}

input AssetCreateWithoutPortfolioInput {
  createdAt: DateTime
  CustomAsset: CustomAssetCreateOneWithoutAssetInput
  description: String
  name: String!
  quantity: Int
  ticker: String
  Transaction: TransactionCreateManyWithoutAssetInput
  updatedAt: DateTime
}

input AssetCreateWithoutTransactionInput {
  createdAt: DateTime
  CustomAsset: CustomAssetCreateOneWithoutAssetInput
  description: String
  name: String!
  Portfolio: PortfolioCreateOneWithoutAssetsInput!
  quantity: Int
  ticker: String
  updatedAt: DateTime
}

input AssetFilter {
  every: AssetWhereInput
  none: AssetWhereInput
  some: AssetWhereInput
}

input AssetScalarWhereInput {
  AND: [AssetScalarWhereInput!]
  createdAt: DateTimeFilter
  description: NullableStringFilter
  id: IntFilter
  name: StringFilter
  NOT: [AssetScalarWhereInput!]
  OR: [AssetScalarWhereInput!]
  portfolioId: IntFilter
  quantity: IntFilter
  ticker: NullableStringFilter
  Transaction: TransactionFilter
  updatedAt: DateTimeFilter
}

input AssetUpdateInput {
  createdAt: DateTime
  CustomAsset: CustomAssetUpdateOneRequiredWithoutAssetInput
  description: String
  name: String
  Portfolio: PortfolioUpdateOneRequiredWithoutAssetsInput
  quantity: Int
  ticker: String
  Transaction: TransactionUpdateManyWithoutAssetInput
  updatedAt: DateTime
}

input AssetUpdateManyDataInput {
  createdAt: DateTime
  description: String
  name: String
  quantity: Int
  ticker: String
  updatedAt: DateTime
}

input AssetUpdateManyWithoutPortfolioInput {
  connect: [AssetWhereUniqueInput!]
  create: [AssetCreateWithoutPortfolioInput!]
  delete: [AssetWhereUniqueInput!]
  deleteMany: [AssetScalarWhereInput!]
  disconnect: [AssetWhereUniqueInput!]
  set: [AssetWhereUniqueInput!]
  update: [AssetUpdateWithWhereUniqueWithoutPortfolioInput!]
  updateMany: [AssetUpdateManyWithWhereNestedInput!]
  upsert: [AssetUpsertWithWhereUniqueWithoutPortfolioInput!]
}

input AssetUpdateManyWithWhereNestedInput {
  data: AssetUpdateManyDataInput!
  where: AssetScalarWhereInput!
}

input AssetUpdateWithoutPortfolioDataInput {
  createdAt: DateTime
  CustomAsset: CustomAssetUpdateOneRequiredWithoutAssetInput
  description: String
  name: String
  quantity: Int
  ticker: String
  Transaction: TransactionUpdateManyWithoutAssetInput
  updatedAt: DateTime
}

input AssetUpdateWithWhereUniqueWithoutPortfolioInput {
  data: AssetUpdateWithoutPortfolioDataInput!
  where: AssetWhereUniqueInput!
}

input AssetUpsertWithWhereUniqueWithoutPortfolioInput {
  create: AssetCreateWithoutPortfolioInput!
  update: AssetUpdateWithoutPortfolioDataInput!
  where: AssetWhereUniqueInput!
}

input AssetWhereInput {
  AND: [AssetWhereInput!]
  createdAt: DateTimeFilter
  CustomAsset: CustomAssetWhereInput
  description: NullableStringFilter
  id: IntFilter
  name: StringFilter
  NOT: [AssetWhereInput!]
  OR: [AssetWhereInput!]
  Portfolio: PortfolioWhereInput
  portfolioId: IntFilter
  quantity: IntFilter
  ticker: NullableStringFilter
  Transaction: TransactionFilter
  updatedAt: DateTimeFilter
}

input AssetWhereUniqueInput {
  id: Int
}

type AuthPayload {
  token: String!
  user: User!
}

input CustomAssetCreateOneWithoutAssetInput {
  connect: CustomAssetWhereUniqueInput
  create: CustomAssetCreateWithoutAssetInput
}

input CustomAssetCreateWithoutAssetInput {
  HistoricalValue: HistoricalValueCreateManyWithoutAssetInput
}

input CustomAssetUpdateOneRequiredWithoutAssetInput {
  connect: CustomAssetWhereUniqueInput
  create: CustomAssetCreateWithoutAssetInput
  update: CustomAssetUpdateWithoutAssetDataInput
  upsert: CustomAssetUpsertWithoutAssetInput
}

input CustomAssetUpdateWithoutAssetDataInput {
  HistoricalValue: HistoricalValueUpdateManyWithoutAssetInput
}

input CustomAssetUpsertWithoutAssetInput {
  create: CustomAssetCreateWithoutAssetInput!
  update: CustomAssetUpdateWithoutAssetDataInput!
}

input CustomAssetWhereInput {
  AND: [CustomAssetWhereInput!]
  asset: AssetWhereInput
  HistoricalValue: HistoricalValueFilter
  id: IntFilter
  NOT: [CustomAssetWhereInput!]
  OR: [CustomAssetWhereInput!]
}

input CustomAssetWhereUniqueInput {
  id: Int
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the
`date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO
8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: DateTime
  notIn: [DateTime!]
}

input HistoricalValueCreateManyWithoutAssetInput {
  connect: [HistoricalValueWhereUniqueInput!]
  create: [HistoricalValueCreateWithoutAssetInput!]
}

input HistoricalValueCreateWithoutAssetInput {
  createdAt: DateTime
  date: DateTime
  unitPrice: Int!
  updatedAt: DateTime
}

input HistoricalValueFilter {
  every: HistoricalValueWhereInput
  none: HistoricalValueWhereInput
  some: HistoricalValueWhereInput
}

input HistoricalValueScalarWhereInput {
  AND: [HistoricalValueScalarWhereInput!]
  assetId: IntFilter
  createdAt: DateTimeFilter
  date: DateTimeFilter
  id: IntFilter
  NOT: [HistoricalValueScalarWhereInput!]
  OR: [HistoricalValueScalarWhereInput!]
  unitPrice: IntFilter
  updatedAt: DateTimeFilter
}

input HistoricalValueUpdateManyDataInput {
  createdAt: DateTime
  date: DateTime
  unitPrice: Int
  updatedAt: DateTime
}

input HistoricalValueUpdateManyWithoutAssetInput {
  connect: [HistoricalValueWhereUniqueInput!]
  create: [HistoricalValueCreateWithoutAssetInput!]
  delete: [HistoricalValueWhereUniqueInput!]
  deleteMany: [HistoricalValueScalarWhereInput!]
  disconnect: [HistoricalValueWhereUniqueInput!]
  set: [HistoricalValueWhereUniqueInput!]
  update: [HistoricalValueUpdateWithWhereUniqueWithoutAssetInput!]
  updateMany: [HistoricalValueUpdateManyWithWhereNestedInput!]
  upsert: [HistoricalValueUpsertWithWhereUniqueWithoutAssetInput!]
}

input HistoricalValueUpdateManyWithWhereNestedInput {
  data: HistoricalValueUpdateManyDataInput!
  where: HistoricalValueScalarWhereInput!
}

input HistoricalValueUpdateWithoutAssetDataInput {
  createdAt: DateTime
  date: DateTime
  unitPrice: Int
  updatedAt: DateTime
}

input HistoricalValueUpdateWithWhereUniqueWithoutAssetInput {
  data: HistoricalValueUpdateWithoutAssetDataInput!
  where: HistoricalValueWhereUniqueInput!
}

input HistoricalValueUpsertWithWhereUniqueWithoutAssetInput {
  create: HistoricalValueCreateWithoutAssetInput!
  update: HistoricalValueUpdateWithoutAssetDataInput!
  where: HistoricalValueWhereUniqueInput!
}

input HistoricalValueWhereInput {
  AND: [HistoricalValueWhereInput!]
  asset: CustomAssetWhereInput
  assetId: IntFilter
  createdAt: DateTimeFilter
  date: DateTimeFilter
  id: IntFilter
  NOT: [HistoricalValueWhereInput!]
  OR: [HistoricalValueWhereInput!]
  unitPrice: IntFilter
  updatedAt: DateTimeFilter
}

input HistoricalValueWhereUniqueInput {
  id: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: Int
  notIn: [Int!]
}

"""
The `JSON` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar Json

type Mutation {
  createOneAsset(data: AssetCreateInput!): Asset!
  createOnePortfolio(data: PortfolioCreateInput!): Portfolio!
  createOneTransaction(data: TransactionCreateInput!): Transaction!
  createOneUser(data: UserCreateInput!): User!
  deleteOneAsset(where: AssetWhereUniqueInput!): Asset
  deleteOnePortfolio(where: PortfolioWhereUniqueInput!): Portfolio
  deleteOneUser(where: UserWhereUniqueInput!): User
  login(email: String!, password: String!): AuthPayload
  updateOneAsset(data: AssetUpdateInput!, where: AssetWhereUniqueInput!): Asset
  updateOnePortfolio(data: PortfolioUpdateInput!, where: PortfolioWhereUniqueInput!): Portfolio
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
}

input NullableStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

type Portfolio {
  assets(after: AssetWhereUniqueInput, before: AssetWhereUniqueInput, first: Int, last: Int): [Asset!]!
  createdAt: DateTime!
  description: String
  id: Int!
  name: String!
  updatedAt: DateTime!
  User: User!
}

input PortfolioCreateInput {
  assets: AssetCreateManyWithoutPortfolioInput
  createdAt: DateTime
  description: String
  name: String!
  updatedAt: DateTime
  User: UserCreateOneWithoutPortfoliosInput!
}

input PortfolioCreateManyWithoutUserInput {
  connect: [PortfolioWhereUniqueInput!]
  create: [PortfolioCreateWithoutUserInput!]
}

input PortfolioCreateOneWithoutAssetsInput {
  connect: PortfolioWhereUniqueInput
  create: PortfolioCreateWithoutAssetsInput
}

input PortfolioCreateWithoutAssetsInput {
  createdAt: DateTime
  description: String
  name: String!
  updatedAt: DateTime
  User: UserCreateOneWithoutPortfoliosInput!
}

input PortfolioCreateWithoutUserInput {
  assets: AssetCreateManyWithoutPortfolioInput
  createdAt: DateTime
  description: String
  name: String!
  updatedAt: DateTime
}

input PortfolioFilter {
  every: PortfolioWhereInput
  none: PortfolioWhereInput
  some: PortfolioWhereInput
}

input PortfolioScalarWhereInput {
  AND: [PortfolioScalarWhereInput!]
  assets: AssetFilter
  createdAt: DateTimeFilter
  description: NullableStringFilter
  id: IntFilter
  name: StringFilter
  NOT: [PortfolioScalarWhereInput!]
  OR: [PortfolioScalarWhereInput!]
  updatedAt: DateTimeFilter
  userId: IntFilter
}

input PortfolioUpdateInput {
  assets: AssetUpdateManyWithoutPortfolioInput
  createdAt: DateTime
  description: String
  name: String
  updatedAt: DateTime
  User: UserUpdateOneRequiredWithoutPortfoliosInput
}

input PortfolioUpdateManyDataInput {
  createdAt: DateTime
  description: String
  name: String
  updatedAt: DateTime
}

input PortfolioUpdateManyWithoutUserInput {
  connect: [PortfolioWhereUniqueInput!]
  create: [PortfolioCreateWithoutUserInput!]
  delete: [PortfolioWhereUniqueInput!]
  deleteMany: [PortfolioScalarWhereInput!]
  disconnect: [PortfolioWhereUniqueInput!]
  set: [PortfolioWhereUniqueInput!]
  update: [PortfolioUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [PortfolioUpdateManyWithWhereNestedInput!]
  upsert: [PortfolioUpsertWithWhereUniqueWithoutUserInput!]
}

input PortfolioUpdateManyWithWhereNestedInput {
  data: PortfolioUpdateManyDataInput!
  where: PortfolioScalarWhereInput!
}

input PortfolioUpdateOneRequiredWithoutAssetsInput {
  connect: PortfolioWhereUniqueInput
  create: PortfolioCreateWithoutAssetsInput
  update: PortfolioUpdateWithoutAssetsDataInput
  upsert: PortfolioUpsertWithoutAssetsInput
}

input PortfolioUpdateWithoutAssetsDataInput {
  createdAt: DateTime
  description: String
  name: String
  updatedAt: DateTime
  User: UserUpdateOneRequiredWithoutPortfoliosInput
}

input PortfolioUpdateWithoutUserDataInput {
  assets: AssetUpdateManyWithoutPortfolioInput
  createdAt: DateTime
  description: String
  name: String
  updatedAt: DateTime
}

input PortfolioUpdateWithWhereUniqueWithoutUserInput {
  data: PortfolioUpdateWithoutUserDataInput!
  where: PortfolioWhereUniqueInput!
}

input PortfolioUpsertWithoutAssetsInput {
  create: PortfolioCreateWithoutAssetsInput!
  update: PortfolioUpdateWithoutAssetsDataInput!
}

input PortfolioUpsertWithWhereUniqueWithoutUserInput {
  create: PortfolioCreateWithoutUserInput!
  update: PortfolioUpdateWithoutUserDataInput!
  where: PortfolioWhereUniqueInput!
}

input PortfolioWhereInput {
  AND: [PortfolioWhereInput!]
  assets: AssetFilter
  createdAt: DateTimeFilter
  description: NullableStringFilter
  id: IntFilter
  name: StringFilter
  NOT: [PortfolioWhereInput!]
  OR: [PortfolioWhereInput!]
  updatedAt: DateTimeFilter
  User: UserWhereInput
  userId: IntFilter
}

input PortfolioWhereUniqueInput {
  id: Int
}

type Query {
  asset(where: AssetWhereUniqueInput!): Asset
  assets(after: AssetWhereUniqueInput, before: AssetWhereUniqueInput, first: Int, last: Int): [Asset!]!
  portfolio(where: PortfolioWhereUniqueInput!): Portfolio
  portfolios(after: PortfolioWhereUniqueInput, before: PortfolioWhereUniqueInput, first: Int, last: Int): [Portfolio!]!
  user(where: UserWhereUniqueInput!): User
  users(after: UserWhereUniqueInput, before: UserWhereUniqueInput, first: Int, last: Int): [User!]!
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

type Transaction {
  asset: Asset!
  assetQuantity: Int!
  createdAt: DateTime!
  currency: String!
  date: DateTime!
  id: Int!
  note: String
  totalPrice: Int!
  unitPrice: Int!
  updatedAt: DateTime!
}

input TransactionCreateInput {
  asset: AssetCreateOneWithoutTransactionInput!
  assetQuantity: Int!
  createdAt: DateTime
  currency: String!
  date: DateTime
  note: String
  TransactionType: TransactionType!
  unitPrice: Int!
  updatedAt: DateTime
}

input TransactionCreateManyWithoutAssetInput {
  connect: [TransactionWhereUniqueInput!]
  create: [TransactionCreateWithoutAssetInput!]
}

input TransactionCreateWithoutAssetInput {
  assetQuantity: Int!
  createdAt: DateTime
  currency: String!
  date: DateTime
  note: String
  totalPrice: Int!
  TransactionType: TransactionType!
  unitPrice: Int!
  updatedAt: DateTime
}

input TransactionFilter {
  every: TransactionWhereInput
  none: TransactionWhereInput
  some: TransactionWhereInput
}

input TransactionScalarWhereInput {
  AND: [TransactionScalarWhereInput!]
  assetId: IntFilter
  assetQuantity: IntFilter
  createdAt: DateTimeFilter
  currency: StringFilter
  date: DateTimeFilter
  id: IntFilter
  NOT: [TransactionScalarWhereInput!]
  note: NullableStringFilter
  OR: [TransactionScalarWhereInput!]
  totalPrice: IntFilter
  TransactionType: TransactionType
  unitPrice: IntFilter
  updatedAt: DateTimeFilter
}

enum TransactionType {
  buy
  sell
}

input TransactionUpdateManyDataInput {
  assetQuantity: Int
  createdAt: DateTime
  currency: String
  date: DateTime
  note: String
  totalPrice: Int
  TransactionType: TransactionType
  unitPrice: Int
  updatedAt: DateTime
}

input TransactionUpdateManyWithoutAssetInput {
  connect: [TransactionWhereUniqueInput!]
  create: [TransactionCreateWithoutAssetInput!]
  delete: [TransactionWhereUniqueInput!]
  deleteMany: [TransactionScalarWhereInput!]
  disconnect: [TransactionWhereUniqueInput!]
  set: [TransactionWhereUniqueInput!]
  update: [TransactionUpdateWithWhereUniqueWithoutAssetInput!]
  updateMany: [TransactionUpdateManyWithWhereNestedInput!]
  upsert: [TransactionUpsertWithWhereUniqueWithoutAssetInput!]
}

input TransactionUpdateManyWithWhereNestedInput {
  data: TransactionUpdateManyDataInput!
  where: TransactionScalarWhereInput!
}

input TransactionUpdateWithoutAssetDataInput {
  assetQuantity: Int
  createdAt: DateTime
  currency: String
  date: DateTime
  note: String
  totalPrice: Int
  TransactionType: TransactionType
  unitPrice: Int
  updatedAt: DateTime
}

input TransactionUpdateWithWhereUniqueWithoutAssetInput {
  data: TransactionUpdateWithoutAssetDataInput!
  where: TransactionWhereUniqueInput!
}

input TransactionUpsertWithWhereUniqueWithoutAssetInput {
  create: TransactionCreateWithoutAssetInput!
  update: TransactionUpdateWithoutAssetDataInput!
  where: TransactionWhereUniqueInput!
}

input TransactionWhereInput {
  AND: [TransactionWhereInput!]
  asset: AssetWhereInput
  assetId: IntFilter
  assetQuantity: IntFilter
  createdAt: DateTimeFilter
  currency: StringFilter
  date: DateTimeFilter
  id: IntFilter
  NOT: [TransactionWhereInput!]
  note: NullableStringFilter
  OR: [TransactionWhereInput!]
  totalPrice: IntFilter
  TransactionType: TransactionType
  unitPrice: IntFilter
  updatedAt: DateTimeFilter
}

input TransactionWhereUniqueInput {
  id: Int
}

type User {
  createdAt: DateTime!
  email: String!
  id: Int!
  name: String!
  updatedAt: DateTime!
}

input UserCreateInput {
  createdAt: DateTime
  email: String!
  name: String!
  password: String!
  portfolios: PortfolioCreateManyWithoutUserInput
  updatedAt: DateTime
}

input UserCreateOneWithoutPortfoliosInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutPortfoliosInput
}

input UserCreateWithoutPortfoliosInput {
  createdAt: DateTime
  email: String!
  name: String!
  password: String!
  updatedAt: DateTime
}

input UserUpdateInput {
  createdAt: DateTime
  email: String
  name: String
  password: String
  portfolios: PortfolioUpdateManyWithoutUserInput
  updatedAt: DateTime
}

input UserUpdateOneRequiredWithoutPortfoliosInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutPortfoliosInput
  update: UserUpdateWithoutPortfoliosDataInput
  upsert: UserUpsertWithoutPortfoliosInput
}

input UserUpdateWithoutPortfoliosDataInput {
  createdAt: DateTime
  email: String
  name: String
  password: String
  updatedAt: DateTime
}

input UserUpsertWithoutPortfoliosInput {
  create: UserCreateWithoutPortfoliosInput!
  update: UserUpdateWithoutPortfoliosDataInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  createdAt: DateTimeFilter
  email: StringFilter
  id: IntFilter
  name: StringFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  password: StringFilter
  portfolios: PortfolioFilter
  updatedAt: DateTimeFilter
}

input UserWhereUniqueInput {
  email: String
  id: Int
}
