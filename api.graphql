### This file was generated by Nexus Schema
### Do not make changes to this file directly


type Asset {
  createdAt: DateTime!
  description: String
  id: Int!
  name: String!
  portfolioId: Int!
  quantity: Int!
  updatedAt: DateTime!
}

input AssetCreateManyWithoutPortfolioInput {
  connect: [AssetWhereUniqueInput!]
  create: [AssetCreateWithoutPortfolioInput!]
}

input AssetCreateOneWithoutPrivateAssetInput {
  connect: AssetWhereUniqueInput
  create: AssetCreateWithoutPrivateAssetInput
}

input AssetCreateOneWithoutPublicAssetInput {
  connect: AssetWhereUniqueInput
  create: AssetCreateWithoutPublicAssetInput
}

input AssetCreateWithoutPortfolioInput {
  createdAt: DateTime
  description: String
  name: String!
  privateAsset: PrivateAssetCreateOneWithoutBaseAssetInput
  publicAsset: PublicAssetCreateOneWithoutBaseAssetInput
  quantity: Int
  transactions: TransactionRecordCreateManyWithoutAssetInput
  updatedAt: DateTime
}

input AssetCreateWithoutPrivateAssetInput {
  createdAt: DateTime
  description: String
  name: String!
  portfolio: PortfolioCreateOneWithoutAssetsInput!
  publicAsset: PublicAssetCreateOneWithoutBaseAssetInput
  quantity: Int
  transactions: TransactionRecordCreateManyWithoutAssetInput
  updatedAt: DateTime
}

input AssetCreateWithoutPublicAssetInput {
  createdAt: DateTime
  description: String
  name: String!
  portfolio: PortfolioCreateOneWithoutAssetsInput!
  privateAsset: PrivateAssetCreateOneWithoutBaseAssetInput
  quantity: Int
  transactions: TransactionRecordCreateManyWithoutAssetInput
  updatedAt: DateTime
}

input AssetScalarWhereInput {
  AND: [AssetScalarWhereInput!]
  createdAt: DateTimeFilter
  description: StringNullableFilter
  id: IntFilter
  name: StringFilter
  NOT: [AssetScalarWhereInput!]
  OR: [AssetScalarWhereInput!]
  portfolioId: IntFilter
  quantity: IntFilter
  updatedAt: DateTimeFilter
}

input AssetUpdateManyDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  quantity: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input AssetUpdateManyWithoutPortfolioInput {
  connect: [AssetWhereUniqueInput!]
  create: [AssetCreateWithoutPortfolioInput!]
  delete: [AssetWhereUniqueInput!]
  deleteMany: [AssetScalarWhereInput!]
  disconnect: [AssetWhereUniqueInput!]
  set: [AssetWhereUniqueInput!]
  update: [AssetUpdateWithWhereUniqueWithoutPortfolioInput!]
  updateMany: [AssetUpdateManyWithWhereNestedInput!]
  upsert: [AssetUpsertWithWhereUniqueWithoutPortfolioInput!]
}

input AssetUpdateManyWithWhereNestedInput {
  data: AssetUpdateManyDataInput!
  where: AssetScalarWhereInput!
}

input AssetUpdateOneRequiredWithoutPrivateAssetInput {
  connect: AssetWhereUniqueInput
  create: AssetCreateWithoutPrivateAssetInput
  update: AssetUpdateWithoutPrivateAssetDataInput
  upsert: AssetUpsertWithoutPrivateAssetInput
}

input AssetUpdateOneRequiredWithoutPublicAssetInput {
  connect: AssetWhereUniqueInput
  create: AssetCreateWithoutPublicAssetInput
  update: AssetUpdateWithoutPublicAssetDataInput
  upsert: AssetUpsertWithoutPublicAssetInput
}

input AssetUpdateWithoutPortfolioDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  privateAsset: PrivateAssetUpdateOneWithoutBaseAssetInput
  publicAsset: PublicAssetUpdateOneWithoutBaseAssetInput
  quantity: IntFieldUpdateOperationsInput
  transactions: TransactionRecordUpdateManyWithoutAssetInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input AssetUpdateWithoutPrivateAssetDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  portfolio: PortfolioUpdateOneRequiredWithoutAssetsInput
  publicAsset: PublicAssetUpdateOneWithoutBaseAssetInput
  quantity: IntFieldUpdateOperationsInput
  transactions: TransactionRecordUpdateManyWithoutAssetInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input AssetUpdateWithoutPublicAssetDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  portfolio: PortfolioUpdateOneRequiredWithoutAssetsInput
  privateAsset: PrivateAssetUpdateOneWithoutBaseAssetInput
  quantity: IntFieldUpdateOperationsInput
  transactions: TransactionRecordUpdateManyWithoutAssetInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input AssetUpdateWithWhereUniqueWithoutPortfolioInput {
  data: AssetUpdateWithoutPortfolioDataInput!
  where: AssetWhereUniqueInput!
}

input AssetUpsertWithoutPrivateAssetInput {
  create: AssetCreateWithoutPrivateAssetInput!
  update: AssetUpdateWithoutPrivateAssetDataInput!
}

input AssetUpsertWithoutPublicAssetInput {
  create: AssetCreateWithoutPublicAssetInput!
  update: AssetUpdateWithoutPublicAssetDataInput!
}

input AssetUpsertWithWhereUniqueWithoutPortfolioInput {
  create: AssetCreateWithoutPortfolioInput!
  update: AssetUpdateWithoutPortfolioDataInput!
  where: AssetWhereUniqueInput!
}

input AssetWhereUniqueInput {
  id: Int
}

type AuthPayload {
  token: String!
  user: User!
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the
`date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO
8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

type HistoricalValue {
  asset: PrivateAsset!
  createdAt: DateTime!
  date: DateTime!
  id: Int!
  unitPrice: Int!
  updatedAt: DateTime!
}

input HistoricalValueCreateInput {
  asset: PrivateAssetCreateOneWithoutHistoricalValuesInput!
  createdAt: DateTime
  date: DateTime
  unitPrice: Int!
  updatedAt: DateTime
}

input HistoricalValueCreateManyWithoutAssetInput {
  connect: [HistoricalValueWhereUniqueInput!]
  create: [HistoricalValueCreateWithoutAssetInput!]
}

input HistoricalValueCreateWithoutAssetInput {
  createdAt: DateTime
  date: DateTime
  unitPrice: Int!
  updatedAt: DateTime
}

input HistoricalValueScalarWhereInput {
  AND: [HistoricalValueScalarWhereInput!]
  assetId: IntFilter
  createdAt: DateTimeFilter
  date: DateTimeFilter
  id: IntFilter
  NOT: [HistoricalValueScalarWhereInput!]
  OR: [HistoricalValueScalarWhereInput!]
  unitPrice: IntFilter
  updatedAt: DateTimeFilter
}

input HistoricalValueUpdateInput {
  asset: PrivateAssetUpdateOneRequiredWithoutHistoricalValuesInput
  createdAt: DateTimeFieldUpdateOperationsInput
  date: DateTimeFieldUpdateOperationsInput
  unitPrice: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input HistoricalValueUpdateManyDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  date: DateTimeFieldUpdateOperationsInput
  unitPrice: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input HistoricalValueUpdateManyWithoutAssetInput {
  connect: [HistoricalValueWhereUniqueInput!]
  create: [HistoricalValueCreateWithoutAssetInput!]
  delete: [HistoricalValueWhereUniqueInput!]
  deleteMany: [HistoricalValueScalarWhereInput!]
  disconnect: [HistoricalValueWhereUniqueInput!]
  set: [HistoricalValueWhereUniqueInput!]
  update: [HistoricalValueUpdateWithWhereUniqueWithoutAssetInput!]
  updateMany: [HistoricalValueUpdateManyWithWhereNestedInput!]
  upsert: [HistoricalValueUpsertWithWhereUniqueWithoutAssetInput!]
}

input HistoricalValueUpdateManyWithWhereNestedInput {
  data: HistoricalValueUpdateManyDataInput!
  where: HistoricalValueScalarWhereInput!
}

input HistoricalValueUpdateWithoutAssetDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  date: DateTimeFieldUpdateOperationsInput
  unitPrice: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input HistoricalValueUpdateWithWhereUniqueWithoutAssetInput {
  data: HistoricalValueUpdateWithoutAssetDataInput!
  where: HistoricalValueWhereUniqueInput!
}

input HistoricalValueUpsertWithWhereUniqueWithoutAssetInput {
  create: HistoricalValueCreateWithoutAssetInput!
  update: HistoricalValueUpdateWithoutAssetDataInput!
  where: HistoricalValueWhereUniqueInput!
}

input HistoricalValueWhereUniqueInput {
  id: Int
}

input IntFieldUpdateOperationsInput {
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

"""
The `JSON` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar Json

type Mutation {
  createOneHistoricalValue(data: HistoricalValueCreateInput!): HistoricalValue!
  createOnePortfolio(data: PortfolioCreateInput!): Portfolio!
  createOnePrivateAsset(data: PrivateAssetCreateInput!): PrivateAsset!
  createOnePublicAsset(data: PublicAssetCreateInput!): PublicAsset!
  createOneUser(data: UserCreateInput!): User!
  deleteOneHistoricalValue(where: HistoricalValueWhereUniqueInput!): HistoricalValue
  deleteOnePortfolio(where: PortfolioWhereUniqueInput!): Portfolio
  deleteOnePrivateAsset(where: PrivateAssetWhereUniqueInput!): PrivateAsset
  deleteOnePublicAsset(where: PublicAssetWhereUniqueInput!): PublicAsset
  deleteOneUser(where: UserWhereUniqueInput!): User
  login(email: String!, password: String!): AuthPayload
  makeTransaction(data: TransactionCreateInput!): Transaction!
  updateOneHistoricalValue(data: HistoricalValueUpdateInput!, where: HistoricalValueWhereUniqueInput!): HistoricalValue
  updateOnePortfolio(data: PortfolioUpdateInput!, where: PortfolioWhereUniqueInput!): Portfolio
  updateOnePrivateAsset(data: PrivateAssetUpdateInput!, where: PrivateAssetWhereUniqueInput!): PrivateAsset
  updateOnePublicAsset(data: PublicAssetUpdateInput!, where: PublicAssetWhereUniqueInput!): PublicAsset
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type Portfolio {
  assets(after: AssetWhereUniqueInput, before: AssetWhereUniqueInput, first: Int, last: Int): [Asset!]!
  createdAt: DateTime!
  description: String
  id: Int!
  name: String!
  owner: User!
  updatedAt: DateTime!
}

input PortfolioCreateInput {
  assets: AssetCreateManyWithoutPortfolioInput
  createdAt: DateTime
  description: String
  name: String!
  owner: UserCreateOneWithoutPortfoliosInput!
  updatedAt: DateTime
}

input PortfolioCreateManyWithoutOwnerInput {
  connect: [PortfolioWhereUniqueInput!]
  create: [PortfolioCreateWithoutOwnerInput!]
}

input PortfolioCreateOneWithoutAssetsInput {
  connect: PortfolioWhereUniqueInput
  create: PortfolioCreateWithoutAssetsInput
}

input PortfolioCreateWithoutAssetsInput {
  createdAt: DateTime
  description: String
  name: String!
  owner: UserCreateOneWithoutPortfoliosInput!
  updatedAt: DateTime
}

input PortfolioCreateWithoutOwnerInput {
  assets: AssetCreateManyWithoutPortfolioInput
  createdAt: DateTime
  description: String
  name: String!
  updatedAt: DateTime
}

input PortfolioScalarWhereInput {
  AND: [PortfolioScalarWhereInput!]
  createdAt: DateTimeFilter
  description: StringNullableFilter
  id: IntFilter
  name: StringFilter
  NOT: [PortfolioScalarWhereInput!]
  OR: [PortfolioScalarWhereInput!]
  updatedAt: DateTimeFilter
  userId: IntFilter
}

input PortfolioUpdateInput {
  assets: AssetUpdateManyWithoutPortfolioInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  owner: UserUpdateOneRequiredWithoutPortfoliosInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input PortfolioUpdateManyDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input PortfolioUpdateManyWithoutOwnerInput {
  connect: [PortfolioWhereUniqueInput!]
  create: [PortfolioCreateWithoutOwnerInput!]
  delete: [PortfolioWhereUniqueInput!]
  deleteMany: [PortfolioScalarWhereInput!]
  disconnect: [PortfolioWhereUniqueInput!]
  set: [PortfolioWhereUniqueInput!]
  update: [PortfolioUpdateWithWhereUniqueWithoutOwnerInput!]
  updateMany: [PortfolioUpdateManyWithWhereNestedInput!]
  upsert: [PortfolioUpsertWithWhereUniqueWithoutOwnerInput!]
}

input PortfolioUpdateManyWithWhereNestedInput {
  data: PortfolioUpdateManyDataInput!
  where: PortfolioScalarWhereInput!
}

input PortfolioUpdateOneRequiredWithoutAssetsInput {
  connect: PortfolioWhereUniqueInput
  create: PortfolioCreateWithoutAssetsInput
  update: PortfolioUpdateWithoutAssetsDataInput
  upsert: PortfolioUpsertWithoutAssetsInput
}

input PortfolioUpdateWithoutAssetsDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  owner: UserUpdateOneRequiredWithoutPortfoliosInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input PortfolioUpdateWithoutOwnerDataInput {
  assets: AssetUpdateManyWithoutPortfolioInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input PortfolioUpdateWithWhereUniqueWithoutOwnerInput {
  data: PortfolioUpdateWithoutOwnerDataInput!
  where: PortfolioWhereUniqueInput!
}

input PortfolioUpsertWithoutAssetsInput {
  create: PortfolioCreateWithoutAssetsInput!
  update: PortfolioUpdateWithoutAssetsDataInput!
}

input PortfolioUpsertWithWhereUniqueWithoutOwnerInput {
  create: PortfolioCreateWithoutOwnerInput!
  update: PortfolioUpdateWithoutOwnerDataInput!
  where: PortfolioWhereUniqueInput!
}

input PortfolioWhereUniqueInput {
  id: Int
}

"""
Privately traded asset. For assets that are not traded on a supported public market.
"""
type PrivateAsset {
  baseAsset: Asset!
  historicalValues(after: HistoricalValueWhereUniqueInput, before: HistoricalValueWhereUniqueInput, first: Int, last: Int): [HistoricalValue!]!
  id: Int!
}

input PrivateAssetCreateInput {
  baseAsset: AssetCreateOneWithoutPrivateAssetInput!
  historicalValues: HistoricalValueCreateManyWithoutAssetInput
}

input PrivateAssetCreateOneWithoutBaseAssetInput {
  connect: PrivateAssetWhereUniqueInput
  create: PrivateAssetCreateWithoutBaseAssetInput
}

input PrivateAssetCreateOneWithoutHistoricalValuesInput {
  connect: PrivateAssetWhereUniqueInput
  create: PrivateAssetCreateWithoutHistoricalValuesInput
}

input PrivateAssetCreateWithoutBaseAssetInput {
  historicalValues: HistoricalValueCreateManyWithoutAssetInput
}

input PrivateAssetCreateWithoutHistoricalValuesInput {
  baseAsset: AssetCreateOneWithoutPrivateAssetInput!
}

input PrivateAssetUpdateInput {
  baseAsset: AssetUpdateOneRequiredWithoutPrivateAssetInput
  historicalValues: HistoricalValueUpdateManyWithoutAssetInput
}

input PrivateAssetUpdateOneRequiredWithoutHistoricalValuesInput {
  connect: PrivateAssetWhereUniqueInput
  create: PrivateAssetCreateWithoutHistoricalValuesInput
  update: PrivateAssetUpdateWithoutHistoricalValuesDataInput
  upsert: PrivateAssetUpsertWithoutHistoricalValuesInput
}

input PrivateAssetUpdateOneWithoutBaseAssetInput {
  connect: PrivateAssetWhereUniqueInput
  create: PrivateAssetCreateWithoutBaseAssetInput
  delete: Boolean
  disconnect: Boolean
  update: PrivateAssetUpdateWithoutBaseAssetDataInput
  upsert: PrivateAssetUpsertWithoutBaseAssetInput
}

input PrivateAssetUpdateWithoutBaseAssetDataInput {
  historicalValues: HistoricalValueUpdateManyWithoutAssetInput
}

input PrivateAssetUpdateWithoutHistoricalValuesDataInput {
  baseAsset: AssetUpdateOneRequiredWithoutPrivateAssetInput
}

input PrivateAssetUpsertWithoutBaseAssetInput {
  create: PrivateAssetCreateWithoutBaseAssetInput!
  update: PrivateAssetUpdateWithoutBaseAssetDataInput!
}

input PrivateAssetUpsertWithoutHistoricalValuesInput {
  create: PrivateAssetCreateWithoutHistoricalValuesInput!
  update: PrivateAssetUpdateWithoutHistoricalValuesDataInput!
}

input PrivateAssetWhereUniqueInput {
  id: Int
}

"""
Publicly traded asset. For assets that are traded in a known and supported public market.
"""
type PublicAsset {
  baseAsset: Asset!
  id: Int!
  market: String
  symbol: String
}

input PublicAssetCreateInput {
  baseAsset: AssetCreateOneWithoutPublicAssetInput!
  market: String
  symbol: String
}

input PublicAssetCreateOneWithoutBaseAssetInput {
  connect: PublicAssetWhereUniqueInput
  create: PublicAssetCreateWithoutBaseAssetInput
}

input PublicAssetCreateWithoutBaseAssetInput {
  market: String
  symbol: String
}

input PublicAssetUpdateInput {
  baseAsset: AssetUpdateOneRequiredWithoutPublicAssetInput
  market: NullableStringFieldUpdateOperationsInput
  symbol: NullableStringFieldUpdateOperationsInput
}

input PublicAssetUpdateOneWithoutBaseAssetInput {
  connect: PublicAssetWhereUniqueInput
  create: PublicAssetCreateWithoutBaseAssetInput
  delete: Boolean
  disconnect: Boolean
  update: PublicAssetUpdateWithoutBaseAssetDataInput
  upsert: PublicAssetUpsertWithoutBaseAssetInput
}

input PublicAssetUpdateWithoutBaseAssetDataInput {
  market: NullableStringFieldUpdateOperationsInput
  symbol: NullableStringFieldUpdateOperationsInput
}

input PublicAssetUpsertWithoutBaseAssetInput {
  create: PublicAssetCreateWithoutBaseAssetInput!
  update: PublicAssetUpdateWithoutBaseAssetDataInput!
}

input PublicAssetWhereUniqueInput {
  id: Int
}

type Query {
  asset(where: AssetWhereUniqueInput!): Asset
  assets(after: AssetWhereUniqueInput, before: AssetWhereUniqueInput, first: Int, last: Int): [Asset!]!
  portfolio(where: PortfolioWhereUniqueInput!): Portfolio
  portfolios(after: PortfolioWhereUniqueInput, before: PortfolioWhereUniqueInput, first: Int, last: Int): [Portfolio!]!
  privateAsset(where: PrivateAssetWhereUniqueInput!): PrivateAsset
  privateAssets(after: PrivateAssetWhereUniqueInput, before: PrivateAssetWhereUniqueInput, first: Int, last: Int): [PrivateAsset!]!
  publicAsset(where: PublicAssetWhereUniqueInput!): PublicAsset
  publicAssets(after: PublicAssetWhereUniqueInput, before: PublicAssetWhereUniqueInput, first: Int, last: Int): [PublicAsset!]!
  user(where: UserWhereUniqueInput!): User
  users(after: UserWhereUniqueInput, before: UserWhereUniqueInput, first: Int, last: Int): [User!]!
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

type Transaction {
  asset: Asset!
  assetId: Int!
  assetQuantity: Int!
  createdAt: DateTime!
  currency: String!
  date: DateTime!
  id: Int!
  note: String
  totalPrice: Int!
  transactionType: TransactionType!
  unitPrice: Int!
  updatedAt: DateTime!
}

input TransactionCreateInput {
  assetId: Int!
  assetQuantity: Int!
  currency: String!
  date: DateTime
  note: String
  transactionType: TransactionType!
  unitPrice: Int!
}

input TransactionRecordCreateManyWithoutAssetInput {
  connect: [TransactionRecordWhereUniqueInput!]
  create: [TransactionRecordCreateWithoutAssetInput!]
}

input TransactionRecordCreateWithoutAssetInput {
  assetQuantity: Int!
  createdAt: DateTime
  currency: String!
  date: DateTime
  note: String
  transactionType: TransactionType!
  unitPrice: Int!
  updatedAt: DateTime
}

input TransactionRecordScalarWhereInput {
  AND: [TransactionRecordScalarWhereInput!]
  assetId: IntFilter
  assetQuantity: IntFilter
  createdAt: DateTimeFilter
  currency: StringFilter
  date: DateTimeFilter
  id: IntFilter
  NOT: [TransactionRecordScalarWhereInput!]
  note: StringNullableFilter
  OR: [TransactionRecordScalarWhereInput!]
  transactionType: TransactionType
  unitPrice: IntFilter
  updatedAt: DateTimeFilter
}

input TransactionRecordUpdateManyDataInput {
  assetQuantity: IntFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  currency: StringFieldUpdateOperationsInput
  date: DateTimeFieldUpdateOperationsInput
  note: NullableStringFieldUpdateOperationsInput
  transactionType: TransactionType
  unitPrice: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input TransactionRecordUpdateManyWithoutAssetInput {
  connect: [TransactionRecordWhereUniqueInput!]
  create: [TransactionRecordCreateWithoutAssetInput!]
  delete: [TransactionRecordWhereUniqueInput!]
  deleteMany: [TransactionRecordScalarWhereInput!]
  disconnect: [TransactionRecordWhereUniqueInput!]
  set: [TransactionRecordWhereUniqueInput!]
  update: [TransactionRecordUpdateWithWhereUniqueWithoutAssetInput!]
  updateMany: [TransactionRecordUpdateManyWithWhereNestedInput!]
  upsert: [TransactionRecordUpsertWithWhereUniqueWithoutAssetInput!]
}

input TransactionRecordUpdateManyWithWhereNestedInput {
  data: TransactionRecordUpdateManyDataInput!
  where: TransactionRecordScalarWhereInput!
}

input TransactionRecordUpdateWithoutAssetDataInput {
  assetQuantity: IntFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  currency: StringFieldUpdateOperationsInput
  date: DateTimeFieldUpdateOperationsInput
  note: NullableStringFieldUpdateOperationsInput
  transactionType: TransactionType
  unitPrice: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input TransactionRecordUpdateWithWhereUniqueWithoutAssetInput {
  data: TransactionRecordUpdateWithoutAssetDataInput!
  where: TransactionRecordWhereUniqueInput!
}

input TransactionRecordUpsertWithWhereUniqueWithoutAssetInput {
  create: TransactionRecordCreateWithoutAssetInput!
  update: TransactionRecordUpdateWithoutAssetDataInput!
  where: TransactionRecordWhereUniqueInput!
}

input TransactionRecordWhereUniqueInput {
  id: Int
}

enum TransactionType {
  buy
  sell
}

type User {
  createdAt: DateTime!
  email: String!
  id: Int!
  name: String!
  updatedAt: DateTime!
}

input UserCreateInput {
  createdAt: DateTime
  email: String!
  name: String!
  password: String!
  portfolios: PortfolioCreateManyWithoutOwnerInput
  updatedAt: DateTime
}

input UserCreateOneWithoutPortfoliosInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutPortfoliosInput
}

input UserCreateWithoutPortfoliosInput {
  createdAt: DateTime
  email: String!
  name: String!
  password: String!
  updatedAt: DateTime
}

input UserUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  portfolios: PortfolioUpdateManyWithoutOwnerInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateOneRequiredWithoutPortfoliosInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutPortfoliosInput
  update: UserUpdateWithoutPortfoliosDataInput
  upsert: UserUpsertWithoutPortfoliosInput
}

input UserUpdateWithoutPortfoliosDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpsertWithoutPortfoliosInput {
  create: UserCreateWithoutPortfoliosInput!
  update: UserUpdateWithoutPortfoliosDataInput!
}

input UserWhereUniqueInput {
  email: String
  id: Int
}
