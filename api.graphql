### This file was generated by Nexus Schema
### Do not make changes to this file directly


type Asset {
  createdAt: DateTime!
  description: String
  id: Int!
  name: String!
  quantity: Int!
  ticker: String
  updatedAt: DateTime!
}

input AssetCreateManyWithoutPortfolioInput {
  connect: [AssetWhereUniqueInput!]
  create: [AssetCreateWithoutPortfolioInput!]
}

input AssetCreateWithoutPortfolioInput {
  createdAt: DateTime
  description: String
  name: String!
  quantity: Int
  ticker: String
  Transaction: TransactionCreateManyWithoutAssetInput
  updatedAt: DateTime
}

input AssetFilter {
  every: AssetWhereInput
  none: AssetWhereInput
  some: AssetWhereInput
}

input AssetScalarWhereInput {
  AND: [AssetScalarWhereInput!]
  createdAt: DateTimeFilter
  description: NullableStringFilter
  id: IntFilter
  name: StringFilter
  NOT: [AssetScalarWhereInput!]
  OR: [AssetScalarWhereInput!]
  portfolioId: NullableIntFilter
  quantity: IntFilter
  ticker: NullableStringFilter
  Transaction: TransactionFilter
  updatedAt: DateTimeFilter
}

input AssetUpdateManyDataInput {
  createdAt: DateTime
  description: String
  name: String
  quantity: Int
  ticker: String
  updatedAt: DateTime
}

input AssetUpdateManyWithoutPortfolioInput {
  connect: [AssetWhereUniqueInput!]
  create: [AssetCreateWithoutPortfolioInput!]
  delete: [AssetWhereUniqueInput!]
  deleteMany: [AssetScalarWhereInput!]
  disconnect: [AssetWhereUniqueInput!]
  set: [AssetWhereUniqueInput!]
  update: [AssetUpdateWithWhereUniqueWithoutPortfolioInput!]
  updateMany: [AssetUpdateManyWithWhereNestedInput!]
  upsert: [AssetUpsertWithWhereUniqueWithoutPortfolioInput!]
}

input AssetUpdateManyWithWhereNestedInput {
  data: AssetUpdateManyDataInput!
  where: AssetScalarWhereInput!
}

input AssetUpdateWithoutPortfolioDataInput {
  createdAt: DateTime
  description: String
  name: String
  quantity: Int
  ticker: String
  Transaction: TransactionUpdateManyWithoutAssetInput
  updatedAt: DateTime
}

input AssetUpdateWithWhereUniqueWithoutPortfolioInput {
  data: AssetUpdateWithoutPortfolioDataInput!
  where: AssetWhereUniqueInput!
}

input AssetUpsertWithWhereUniqueWithoutPortfolioInput {
  create: AssetCreateWithoutPortfolioInput!
  update: AssetUpdateWithoutPortfolioDataInput!
  where: AssetWhereUniqueInput!
}

input AssetWhereInput {
  AND: [AssetWhereInput!]
  createdAt: DateTimeFilter
  description: NullableStringFilter
  id: IntFilter
  name: StringFilter
  NOT: [AssetWhereInput!]
  OR: [AssetWhereInput!]
  Portfolio: PortfolioWhereInput
  portfolioId: NullableIntFilter
  quantity: IntFilter
  ticker: NullableStringFilter
  Transaction: TransactionFilter
  updatedAt: DateTimeFilter
}

input AssetWhereUniqueInput {
  id: Int
}

type AuthPayload {
  token: String!
  user: User!
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the
`date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO
8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: DateTime
  notIn: [DateTime!]
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: Int
  notIn: [Int!]
}

"""
The `JSON` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar Json

type Mutation {
  createOnePortfolio(data: PortfolioCreateInput!): Portfolio!
  createOneUser(data: UserCreateInput!): User!
  deleteOnePortfolio(where: PortfolioWhereUniqueInput!): Portfolio
  deleteOneUser(where: UserWhereUniqueInput!): User
  login(email: String!, password: String!): AuthPayload
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
}

input NullableIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: Int
  notIn: [Int!]
}

input NullableStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

type Portfolio {
  assets(after: AssetWhereUniqueInput, before: AssetWhereUniqueInput, first: Int, last: Int): [Asset!]!
  createdAt: DateTime!
  description: String
  id: Int!
  name: String!
  updatedAt: DateTime!
  User: User
}

input PortfolioCreateInput {
  assets: AssetCreateManyWithoutPortfolioInput
  createdAt: DateTime
  description: String
  name: String!
  updatedAt: DateTime
  User: UserCreateOneWithoutPortfoliosInput
}

input PortfolioCreateManyWithoutUserInput {
  connect: [PortfolioWhereUniqueInput!]
  create: [PortfolioCreateWithoutUserInput!]
}

input PortfolioCreateWithoutUserInput {
  assets: AssetCreateManyWithoutPortfolioInput
  createdAt: DateTime
  description: String
  name: String!
  updatedAt: DateTime
}

input PortfolioFilter {
  every: PortfolioWhereInput
  none: PortfolioWhereInput
  some: PortfolioWhereInput
}

input PortfolioScalarWhereInput {
  AND: [PortfolioScalarWhereInput!]
  assets: AssetFilter
  createdAt: DateTimeFilter
  description: NullableStringFilter
  id: IntFilter
  name: StringFilter
  NOT: [PortfolioScalarWhereInput!]
  OR: [PortfolioScalarWhereInput!]
  updatedAt: DateTimeFilter
  userId: NullableIntFilter
}

input PortfolioUpdateManyDataInput {
  createdAt: DateTime
  description: String
  name: String
  updatedAt: DateTime
}

input PortfolioUpdateManyWithoutUserInput {
  connect: [PortfolioWhereUniqueInput!]
  create: [PortfolioCreateWithoutUserInput!]
  delete: [PortfolioWhereUniqueInput!]
  deleteMany: [PortfolioScalarWhereInput!]
  disconnect: [PortfolioWhereUniqueInput!]
  set: [PortfolioWhereUniqueInput!]
  update: [PortfolioUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [PortfolioUpdateManyWithWhereNestedInput!]
  upsert: [PortfolioUpsertWithWhereUniqueWithoutUserInput!]
}

input PortfolioUpdateManyWithWhereNestedInput {
  data: PortfolioUpdateManyDataInput!
  where: PortfolioScalarWhereInput!
}

input PortfolioUpdateWithoutUserDataInput {
  assets: AssetUpdateManyWithoutPortfolioInput
  createdAt: DateTime
  description: String
  name: String
  updatedAt: DateTime
}

input PortfolioUpdateWithWhereUniqueWithoutUserInput {
  data: PortfolioUpdateWithoutUserDataInput!
  where: PortfolioWhereUniqueInput!
}

input PortfolioUpsertWithWhereUniqueWithoutUserInput {
  create: PortfolioCreateWithoutUserInput!
  update: PortfolioUpdateWithoutUserDataInput!
  where: PortfolioWhereUniqueInput!
}

input PortfolioWhereInput {
  AND: [PortfolioWhereInput!]
  assets: AssetFilter
  createdAt: DateTimeFilter
  description: NullableStringFilter
  id: IntFilter
  name: StringFilter
  NOT: [PortfolioWhereInput!]
  OR: [PortfolioWhereInput!]
  updatedAt: DateTimeFilter
  User: UserWhereInput
  userId: NullableIntFilter
}

input PortfolioWhereUniqueInput {
  id: Int
}

type Query {
  asset(where: AssetWhereUniqueInput!): Asset
  assets(after: AssetWhereUniqueInput, before: AssetWhereUniqueInput, first: Int, last: Int): [Asset!]!
  portfolio(where: PortfolioWhereUniqueInput!): Portfolio
  portfolios(after: PortfolioWhereUniqueInput, before: PortfolioWhereUniqueInput, first: Int, last: Int): [Portfolio!]!
  user(where: UserWhereUniqueInput!): User
  users(after: UserWhereUniqueInput, before: UserWhereUniqueInput, first: Int, last: Int): [User!]!
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

input TransactionCreateManyWithoutAssetInput {
  connect: [TransactionWhereUniqueInput!]
  create: [TransactionCreateWithoutAssetInput!]
}

input TransactionCreateWithoutAssetInput {
  assetQuantity: Int!
  createdAt: DateTime
  currency: String!
  date: DateTime
  note: String
  totalPrice: Int!
  unitPrice: Int!
  updatedAt: DateTime
}

input TransactionFilter {
  every: TransactionWhereInput
  none: TransactionWhereInput
  some: TransactionWhereInput
}

input TransactionScalarWhereInput {
  AND: [TransactionScalarWhereInput!]
  assetId: IntFilter
  assetQuantity: IntFilter
  createdAt: DateTimeFilter
  currency: StringFilter
  date: DateTimeFilter
  id: IntFilter
  NOT: [TransactionScalarWhereInput!]
  note: NullableStringFilter
  OR: [TransactionScalarWhereInput!]
  totalPrice: IntFilter
  unitPrice: IntFilter
  updatedAt: DateTimeFilter
}

input TransactionUpdateManyDataInput {
  assetQuantity: Int
  createdAt: DateTime
  currency: String
  date: DateTime
  note: String
  totalPrice: Int
  unitPrice: Int
  updatedAt: DateTime
}

input TransactionUpdateManyWithoutAssetInput {
  connect: [TransactionWhereUniqueInput!]
  create: [TransactionCreateWithoutAssetInput!]
  delete: [TransactionWhereUniqueInput!]
  deleteMany: [TransactionScalarWhereInput!]
  disconnect: [TransactionWhereUniqueInput!]
  set: [TransactionWhereUniqueInput!]
  update: [TransactionUpdateWithWhereUniqueWithoutAssetInput!]
  updateMany: [TransactionUpdateManyWithWhereNestedInput!]
  upsert: [TransactionUpsertWithWhereUniqueWithoutAssetInput!]
}

input TransactionUpdateManyWithWhereNestedInput {
  data: TransactionUpdateManyDataInput!
  where: TransactionScalarWhereInput!
}

input TransactionUpdateWithoutAssetDataInput {
  assetQuantity: Int
  createdAt: DateTime
  currency: String
  date: DateTime
  note: String
  totalPrice: Int
  unitPrice: Int
  updatedAt: DateTime
}

input TransactionUpdateWithWhereUniqueWithoutAssetInput {
  data: TransactionUpdateWithoutAssetDataInput!
  where: TransactionWhereUniqueInput!
}

input TransactionUpsertWithWhereUniqueWithoutAssetInput {
  create: TransactionCreateWithoutAssetInput!
  update: TransactionUpdateWithoutAssetDataInput!
  where: TransactionWhereUniqueInput!
}

input TransactionWhereInput {
  AND: [TransactionWhereInput!]
  asset: AssetWhereInput
  assetId: IntFilter
  assetQuantity: IntFilter
  createdAt: DateTimeFilter
  currency: StringFilter
  date: DateTimeFilter
  id: IntFilter
  NOT: [TransactionWhereInput!]
  note: NullableStringFilter
  OR: [TransactionWhereInput!]
  totalPrice: IntFilter
  unitPrice: IntFilter
  updatedAt: DateTimeFilter
}

input TransactionWhereUniqueInput {
  id: Int
}

type User {
  createdAt: DateTime!
  email: String!
  id: Int!
  name: String!
  updatedAt: DateTime!
}

input UserCreateInput {
  createdAt: DateTime
  email: String!
  name: String!
  password: String!
  portfolios: PortfolioCreateManyWithoutUserInput
  updatedAt: DateTime
}

input UserCreateOneWithoutPortfoliosInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutPortfoliosInput
}

input UserCreateWithoutPortfoliosInput {
  createdAt: DateTime
  email: String!
  name: String!
  password: String!
  updatedAt: DateTime
}

input UserUpdateInput {
  createdAt: DateTime
  email: String
  name: String
  password: String
  portfolios: PortfolioUpdateManyWithoutUserInput
  updatedAt: DateTime
}

input UserWhereInput {
  AND: [UserWhereInput!]
  createdAt: DateTimeFilter
  email: StringFilter
  id: IntFilter
  name: StringFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  password: StringFilter
  portfolios: PortfolioFilter
  updatedAt: DateTimeFilter
}

input UserWhereUniqueInput {
  email: String
  id: Int
}
