### This file was generated by Nexus Schema
### Do not make changes to this file directly


type Asset {
  createdAt: DateTime!
  description: String
  id: Int!
  name: String!
  portfolioId: Int!
  quantity: Int!
  updatedAt: DateTime!
}

input AssetCreateInput {
  createdAt: DateTime
  description: String
  name: String!
  portfolio: PortfolioCreateOneWithoutAssetsInput!
  PrivateAsset: PrivateAssetCreateOneWithoutAssetInput
  PublicAsset: PublicAssetCreateOneWithoutAssetInput
  transaction: TransactionCreateManyWithoutAssetInput
  updatedAt: DateTime
}

input AssetCreateManyWithoutPortfolioInput {
  connect: [AssetWhereUniqueInput!]
  create: [AssetCreateWithoutPortfolioInput!]
}

input AssetCreateOneWithoutPrivateAssetInput {
  connect: AssetWhereUniqueInput
  create: AssetCreateWithoutPrivateAssetInput
}

input AssetCreateOneWithoutPublicAssetInput {
  connect: AssetWhereUniqueInput
  create: AssetCreateWithoutPublicAssetInput
}

input AssetCreateOneWithoutTransactionInput {
  connect: AssetWhereUniqueInput
  create: AssetCreateWithoutTransactionInput
}

input AssetCreateWithoutPortfolioInput {
  createdAt: DateTime
  description: String
  name: String!
  PrivateAsset: PrivateAssetCreateOneWithoutAssetInput
  PublicAsset: PublicAssetCreateOneWithoutAssetInput
  quantity: Int
  transaction: TransactionCreateManyWithoutAssetInput
  updatedAt: DateTime
}

input AssetCreateWithoutPrivateAssetInput {
  createdAt: DateTime
  description: String
  name: String!
  portfolio: PortfolioCreateOneWithoutAssetsInput!
  PublicAsset: PublicAssetCreateOneWithoutAssetInput
  quantity: Int
  transaction: TransactionCreateManyWithoutAssetInput
  updatedAt: DateTime
}

input AssetCreateWithoutPublicAssetInput {
  createdAt: DateTime
  description: String
  name: String!
  portfolio: PortfolioCreateOneWithoutAssetsInput!
  PrivateAsset: PrivateAssetCreateOneWithoutAssetInput
  quantity: Int
  transaction: TransactionCreateManyWithoutAssetInput
  updatedAt: DateTime
}

input AssetCreateWithoutTransactionInput {
  createdAt: DateTime
  description: String
  name: String!
  portfolio: PortfolioCreateOneWithoutAssetsInput!
  PrivateAsset: PrivateAssetCreateOneWithoutAssetInput
  PublicAsset: PublicAssetCreateOneWithoutAssetInput
  quantity: Int
  updatedAt: DateTime
}

input AssetFilter {
  every: AssetWhereInput
  none: AssetWhereInput
  some: AssetWhereInput
}

input AssetScalarWhereInput {
  AND: [AssetScalarWhereInput!]
  createdAt: DateTimeFilter
  description: NullableStringFilter
  id: IntFilter
  name: StringFilter
  NOT: [AssetScalarWhereInput!]
  OR: [AssetScalarWhereInput!]
  portfolioId: IntFilter
  quantity: IntFilter
  transaction: TransactionFilter
  updatedAt: DateTimeFilter
}

input AssetUpdateInput {
  createdAt: DateTime
  description: String
  name: String
  portfolio: PortfolioUpdateOneRequiredWithoutAssetsInput
  PrivateAsset: PrivateAssetUpdateOneRequiredWithoutAssetInput
  PublicAsset: PublicAssetUpdateOneRequiredWithoutAssetInput
  quantity: Int
  transaction: TransactionUpdateManyWithoutAssetInput
  updatedAt: DateTime
}

input AssetUpdateManyDataInput {
  createdAt: DateTime
  description: String
  name: String
  quantity: Int
  updatedAt: DateTime
}

input AssetUpdateManyWithoutPortfolioInput {
  connect: [AssetWhereUniqueInput!]
  create: [AssetCreateWithoutPortfolioInput!]
  delete: [AssetWhereUniqueInput!]
  deleteMany: [AssetScalarWhereInput!]
  disconnect: [AssetWhereUniqueInput!]
  set: [AssetWhereUniqueInput!]
  update: [AssetUpdateWithWhereUniqueWithoutPortfolioInput!]
  updateMany: [AssetUpdateManyWithWhereNestedInput!]
  upsert: [AssetUpsertWithWhereUniqueWithoutPortfolioInput!]
}

input AssetUpdateManyWithWhereNestedInput {
  data: AssetUpdateManyDataInput!
  where: AssetScalarWhereInput!
}

input AssetUpdateOneRequiredWithoutPrivateAssetInput {
  connect: AssetWhereUniqueInput
  create: AssetCreateWithoutPrivateAssetInput
  update: AssetUpdateWithoutPrivateAssetDataInput
  upsert: AssetUpsertWithoutPrivateAssetInput
}

input AssetUpdateOneRequiredWithoutPublicAssetInput {
  connect: AssetWhereUniqueInput
  create: AssetCreateWithoutPublicAssetInput
  update: AssetUpdateWithoutPublicAssetDataInput
  upsert: AssetUpsertWithoutPublicAssetInput
}

input AssetUpdateWithoutPortfolioDataInput {
  createdAt: DateTime
  description: String
  name: String
  PrivateAsset: PrivateAssetUpdateOneRequiredWithoutAssetInput
  PublicAsset: PublicAssetUpdateOneRequiredWithoutAssetInput
  quantity: Int
  transaction: TransactionUpdateManyWithoutAssetInput
  updatedAt: DateTime
}

input AssetUpdateWithoutPrivateAssetDataInput {
  createdAt: DateTime
  description: String
  name: String
  portfolio: PortfolioUpdateOneRequiredWithoutAssetsInput
  PublicAsset: PublicAssetUpdateOneRequiredWithoutAssetInput
  quantity: Int
  transaction: TransactionUpdateManyWithoutAssetInput
  updatedAt: DateTime
}

input AssetUpdateWithoutPublicAssetDataInput {
  createdAt: DateTime
  description: String
  name: String
  portfolio: PortfolioUpdateOneRequiredWithoutAssetsInput
  PrivateAsset: PrivateAssetUpdateOneRequiredWithoutAssetInput
  quantity: Int
  transaction: TransactionUpdateManyWithoutAssetInput
  updatedAt: DateTime
}

input AssetUpdateWithWhereUniqueWithoutPortfolioInput {
  data: AssetUpdateWithoutPortfolioDataInput!
  where: AssetWhereUniqueInput!
}

input AssetUpsertWithoutPrivateAssetInput {
  create: AssetCreateWithoutPrivateAssetInput!
  update: AssetUpdateWithoutPrivateAssetDataInput!
}

input AssetUpsertWithoutPublicAssetInput {
  create: AssetCreateWithoutPublicAssetInput!
  update: AssetUpdateWithoutPublicAssetDataInput!
}

input AssetUpsertWithWhereUniqueWithoutPortfolioInput {
  create: AssetCreateWithoutPortfolioInput!
  update: AssetUpdateWithoutPortfolioDataInput!
  where: AssetWhereUniqueInput!
}

input AssetWhereInput {
  AND: [AssetWhereInput!]
  createdAt: DateTimeFilter
  description: NullableStringFilter
  id: IntFilter
  name: StringFilter
  NOT: [AssetWhereInput!]
  OR: [AssetWhereInput!]
  portfolio: PortfolioWhereInput
  portfolioId: IntFilter
  PrivateAsset: PrivateAssetWhereInput
  PublicAsset: PublicAssetWhereInput
  quantity: IntFilter
  transaction: TransactionFilter
  updatedAt: DateTimeFilter
}

input AssetWhereUniqueInput {
  id: Int
}

type AuthPayload {
  token: String!
  user: User!
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the
`date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO
8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: DateTime
  notIn: [DateTime!]
}

type HistoricalValue {
  asset: PrivateAsset!
  createdAt: DateTime!
  date: DateTime!
  id: Int!
  unitPrice: Int!
  updatedAt: DateTime!
}

input HistoricalValueCreateInput {
  asset: PrivateAssetCreateOneWithoutHistoricalValuesInput!
  createdAt: DateTime
  date: DateTime
  unitPrice: Int!
  updatedAt: DateTime
}

input HistoricalValueCreateManyWithoutAssetInput {
  connect: [HistoricalValueWhereUniqueInput!]
  create: [HistoricalValueCreateWithoutAssetInput!]
}

input HistoricalValueCreateWithoutAssetInput {
  createdAt: DateTime
  date: DateTime
  unitPrice: Int!
  updatedAt: DateTime
}

input HistoricalValueFilter {
  every: HistoricalValueWhereInput
  none: HistoricalValueWhereInput
  some: HistoricalValueWhereInput
}

input HistoricalValueScalarWhereInput {
  AND: [HistoricalValueScalarWhereInput!]
  assetId: IntFilter
  createdAt: DateTimeFilter
  date: DateTimeFilter
  id: IntFilter
  NOT: [HistoricalValueScalarWhereInput!]
  OR: [HistoricalValueScalarWhereInput!]
  unitPrice: IntFilter
  updatedAt: DateTimeFilter
}

input HistoricalValueUpdateInput {
  asset: PrivateAssetUpdateOneRequiredWithoutHistoricalValuesInput
  createdAt: DateTime
  date: DateTime
  unitPrice: Int
  updatedAt: DateTime
}

input HistoricalValueUpdateManyDataInput {
  createdAt: DateTime
  date: DateTime
  unitPrice: Int
  updatedAt: DateTime
}

input HistoricalValueUpdateManyWithoutAssetInput {
  connect: [HistoricalValueWhereUniqueInput!]
  create: [HistoricalValueCreateWithoutAssetInput!]
  delete: [HistoricalValueWhereUniqueInput!]
  deleteMany: [HistoricalValueScalarWhereInput!]
  disconnect: [HistoricalValueWhereUniqueInput!]
  set: [HistoricalValueWhereUniqueInput!]
  update: [HistoricalValueUpdateWithWhereUniqueWithoutAssetInput!]
  updateMany: [HistoricalValueUpdateManyWithWhereNestedInput!]
  upsert: [HistoricalValueUpsertWithWhereUniqueWithoutAssetInput!]
}

input HistoricalValueUpdateManyWithWhereNestedInput {
  data: HistoricalValueUpdateManyDataInput!
  where: HistoricalValueScalarWhereInput!
}

input HistoricalValueUpdateWithoutAssetDataInput {
  createdAt: DateTime
  date: DateTime
  unitPrice: Int
  updatedAt: DateTime
}

input HistoricalValueUpdateWithWhereUniqueWithoutAssetInput {
  data: HistoricalValueUpdateWithoutAssetDataInput!
  where: HistoricalValueWhereUniqueInput!
}

input HistoricalValueUpsertWithWhereUniqueWithoutAssetInput {
  create: HistoricalValueCreateWithoutAssetInput!
  update: HistoricalValueUpdateWithoutAssetDataInput!
  where: HistoricalValueWhereUniqueInput!
}

input HistoricalValueWhereInput {
  AND: [HistoricalValueWhereInput!]
  asset: PrivateAssetWhereInput
  assetId: IntFilter
  createdAt: DateTimeFilter
  date: DateTimeFilter
  id: IntFilter
  NOT: [HistoricalValueWhereInput!]
  OR: [HistoricalValueWhereInput!]
  unitPrice: IntFilter
  updatedAt: DateTimeFilter
}

input HistoricalValueWhereUniqueInput {
  id: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: Int
  notIn: [Int!]
}

"""
The `JSON` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar Json

type Mutation {
  createOneAsset(data: AssetCreateInput!): Asset!
  createOneHistoricalValue(data: HistoricalValueCreateInput!): HistoricalValue!
  createOnePortfolio(data: PortfolioCreateInput!): Portfolio!
  createOnePrivateAsset(data: PrivateAssetCreateInput!): PrivateAsset!
  createOnePublicAsset(data: PublicAssetCreateInput!): PublicAsset!
  createOneTransaction(data: TransactionCreateInput!): Transaction!
  createOneUser(data: UserCreateInput!): User!
  deleteOneAsset(where: AssetWhereUniqueInput!): Asset
  deleteOneHistoricalValue(where: HistoricalValueWhereUniqueInput!): HistoricalValue
  deleteOnePortfolio(where: PortfolioWhereUniqueInput!): Portfolio
  deleteOnePrivateAsset(where: PrivateAssetWhereUniqueInput!): PrivateAsset
  deleteOnePublicAsset(where: PublicAssetWhereUniqueInput!): PublicAsset
  deleteOneUser(where: UserWhereUniqueInput!): User
  login(email: String!, password: String!): AuthPayload
  updateOneAsset(data: AssetUpdateInput!, where: AssetWhereUniqueInput!): Asset
  updateOneHistoricalValue(data: HistoricalValueUpdateInput!, where: HistoricalValueWhereUniqueInput!): HistoricalValue
  updateOnePortfolio(data: PortfolioUpdateInput!, where: PortfolioWhereUniqueInput!): Portfolio
  updateOnePrivateAsset(data: PrivateAssetUpdateInput!, where: PrivateAssetWhereUniqueInput!): PrivateAsset
  updateOnePublicAsset(data: PublicAssetUpdateInput!, where: PublicAssetWhereUniqueInput!): PublicAsset
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
}

input NullableStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

type Portfolio {
  assets(after: AssetWhereUniqueInput, before: AssetWhereUniqueInput, first: Int, last: Int): [Asset!]!
  createdAt: DateTime!
  description: String
  id: Int!
  name: String!
  updatedAt: DateTime!
  User: User!
}

input PortfolioCreateInput {
  assets: AssetCreateManyWithoutPortfolioInput
  createdAt: DateTime
  description: String
  name: String!
  updatedAt: DateTime
  User: UserCreateOneWithoutPortfoliosInput!
}

input PortfolioCreateManyWithoutUserInput {
  connect: [PortfolioWhereUniqueInput!]
  create: [PortfolioCreateWithoutUserInput!]
}

input PortfolioCreateOneWithoutAssetsInput {
  connect: PortfolioWhereUniqueInput
  create: PortfolioCreateWithoutAssetsInput
}

input PortfolioCreateWithoutAssetsInput {
  createdAt: DateTime
  description: String
  name: String!
  updatedAt: DateTime
  User: UserCreateOneWithoutPortfoliosInput!
}

input PortfolioCreateWithoutUserInput {
  assets: AssetCreateManyWithoutPortfolioInput
  createdAt: DateTime
  description: String
  name: String!
  updatedAt: DateTime
}

input PortfolioFilter {
  every: PortfolioWhereInput
  none: PortfolioWhereInput
  some: PortfolioWhereInput
}

input PortfolioScalarWhereInput {
  AND: [PortfolioScalarWhereInput!]
  assets: AssetFilter
  createdAt: DateTimeFilter
  description: NullableStringFilter
  id: IntFilter
  name: StringFilter
  NOT: [PortfolioScalarWhereInput!]
  OR: [PortfolioScalarWhereInput!]
  updatedAt: DateTimeFilter
  userId: IntFilter
}

input PortfolioUpdateInput {
  assets: AssetUpdateManyWithoutPortfolioInput
  createdAt: DateTime
  description: String
  name: String
  updatedAt: DateTime
  User: UserUpdateOneRequiredWithoutPortfoliosInput
}

input PortfolioUpdateManyDataInput {
  createdAt: DateTime
  description: String
  name: String
  updatedAt: DateTime
}

input PortfolioUpdateManyWithoutUserInput {
  connect: [PortfolioWhereUniqueInput!]
  create: [PortfolioCreateWithoutUserInput!]
  delete: [PortfolioWhereUniqueInput!]
  deleteMany: [PortfolioScalarWhereInput!]
  disconnect: [PortfolioWhereUniqueInput!]
  set: [PortfolioWhereUniqueInput!]
  update: [PortfolioUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [PortfolioUpdateManyWithWhereNestedInput!]
  upsert: [PortfolioUpsertWithWhereUniqueWithoutUserInput!]
}

input PortfolioUpdateManyWithWhereNestedInput {
  data: PortfolioUpdateManyDataInput!
  where: PortfolioScalarWhereInput!
}

input PortfolioUpdateOneRequiredWithoutAssetsInput {
  connect: PortfolioWhereUniqueInput
  create: PortfolioCreateWithoutAssetsInput
  update: PortfolioUpdateWithoutAssetsDataInput
  upsert: PortfolioUpsertWithoutAssetsInput
}

input PortfolioUpdateWithoutAssetsDataInput {
  createdAt: DateTime
  description: String
  name: String
  updatedAt: DateTime
  User: UserUpdateOneRequiredWithoutPortfoliosInput
}

input PortfolioUpdateWithoutUserDataInput {
  assets: AssetUpdateManyWithoutPortfolioInput
  createdAt: DateTime
  description: String
  name: String
  updatedAt: DateTime
}

input PortfolioUpdateWithWhereUniqueWithoutUserInput {
  data: PortfolioUpdateWithoutUserDataInput!
  where: PortfolioWhereUniqueInput!
}

input PortfolioUpsertWithoutAssetsInput {
  create: PortfolioCreateWithoutAssetsInput!
  update: PortfolioUpdateWithoutAssetsDataInput!
}

input PortfolioUpsertWithWhereUniqueWithoutUserInput {
  create: PortfolioCreateWithoutUserInput!
  update: PortfolioUpdateWithoutUserDataInput!
  where: PortfolioWhereUniqueInput!
}

input PortfolioWhereInput {
  AND: [PortfolioWhereInput!]
  assets: AssetFilter
  createdAt: DateTimeFilter
  description: NullableStringFilter
  id: IntFilter
  name: StringFilter
  NOT: [PortfolioWhereInput!]
  OR: [PortfolioWhereInput!]
  updatedAt: DateTimeFilter
  User: UserWhereInput
  userId: IntFilter
}

input PortfolioWhereUniqueInput {
  id: Int
}

"""
Privately traded asset. For assets that are not traded on a supported public market.
"""
type PrivateAsset {
  asset: Asset!
  historicalValues(after: HistoricalValueWhereUniqueInput, before: HistoricalValueWhereUniqueInput, first: Int, last: Int): [HistoricalValue!]!
  id: Int!
}

input PrivateAssetCreateInput {
  asset: AssetCreateOneWithoutPrivateAssetInput!
  historicalValues: HistoricalValueCreateManyWithoutAssetInput
}

input PrivateAssetCreateOneWithoutAssetInput {
  connect: PrivateAssetWhereUniqueInput
  create: PrivateAssetCreateWithoutAssetInput
}

input PrivateAssetCreateOneWithoutHistoricalValuesInput {
  connect: PrivateAssetWhereUniqueInput
  create: PrivateAssetCreateWithoutHistoricalValuesInput
}

input PrivateAssetCreateWithoutAssetInput {
  historicalValues: HistoricalValueCreateManyWithoutAssetInput
}

input PrivateAssetCreateWithoutHistoricalValuesInput {
  asset: AssetCreateOneWithoutPrivateAssetInput!
}

input PrivateAssetUpdateInput {
  asset: AssetUpdateOneRequiredWithoutPrivateAssetInput
  historicalValues: HistoricalValueUpdateManyWithoutAssetInput
}

input PrivateAssetUpdateOneRequiredWithoutAssetInput {
  connect: PrivateAssetWhereUniqueInput
  create: PrivateAssetCreateWithoutAssetInput
  update: PrivateAssetUpdateWithoutAssetDataInput
  upsert: PrivateAssetUpsertWithoutAssetInput
}

input PrivateAssetUpdateOneRequiredWithoutHistoricalValuesInput {
  connect: PrivateAssetWhereUniqueInput
  create: PrivateAssetCreateWithoutHistoricalValuesInput
  update: PrivateAssetUpdateWithoutHistoricalValuesDataInput
  upsert: PrivateAssetUpsertWithoutHistoricalValuesInput
}

input PrivateAssetUpdateWithoutAssetDataInput {
  historicalValues: HistoricalValueUpdateManyWithoutAssetInput
}

input PrivateAssetUpdateWithoutHistoricalValuesDataInput {
  asset: AssetUpdateOneRequiredWithoutPrivateAssetInput
}

input PrivateAssetUpsertWithoutAssetInput {
  create: PrivateAssetCreateWithoutAssetInput!
  update: PrivateAssetUpdateWithoutAssetDataInput!
}

input PrivateAssetUpsertWithoutHistoricalValuesInput {
  create: PrivateAssetCreateWithoutHistoricalValuesInput!
  update: PrivateAssetUpdateWithoutHistoricalValuesDataInput!
}

input PrivateAssetWhereInput {
  AND: [PrivateAssetWhereInput!]
  asset: AssetWhereInput
  historicalValues: HistoricalValueFilter
  id: IntFilter
  NOT: [PrivateAssetWhereInput!]
  OR: [PrivateAssetWhereInput!]
}

input PrivateAssetWhereUniqueInput {
  id: Int
}

"""
Publicly traded asset. For assets that are traded in a known and supported public market.
"""
type PublicAsset {
  id: Int!
  market: String
  symbol: String
}

input PublicAssetCreateInput {
  asset: AssetCreateOneWithoutPublicAssetInput!
  market: String
  symbol: String
}

input PublicAssetCreateOneWithoutAssetInput {
  connect: PublicAssetWhereUniqueInput
  create: PublicAssetCreateWithoutAssetInput
}

input PublicAssetCreateWithoutAssetInput {
  market: String
  symbol: String
}

input PublicAssetUpdateInput {
  asset: AssetUpdateOneRequiredWithoutPublicAssetInput
  market: String
  symbol: String
}

input PublicAssetUpdateOneRequiredWithoutAssetInput {
  connect: PublicAssetWhereUniqueInput
  create: PublicAssetCreateWithoutAssetInput
  update: PublicAssetUpdateWithoutAssetDataInput
  upsert: PublicAssetUpsertWithoutAssetInput
}

input PublicAssetUpdateWithoutAssetDataInput {
  market: String
  symbol: String
}

input PublicAssetUpsertWithoutAssetInput {
  create: PublicAssetCreateWithoutAssetInput!
  update: PublicAssetUpdateWithoutAssetDataInput!
}

input PublicAssetWhereInput {
  AND: [PublicAssetWhereInput!]
  asset: AssetWhereInput
  id: IntFilter
  market: NullableStringFilter
  NOT: [PublicAssetWhereInput!]
  OR: [PublicAssetWhereInput!]
  symbol: NullableStringFilter
}

input PublicAssetWhereUniqueInput {
  id: Int
}

type Query {
  asset(where: AssetWhereUniqueInput!): Asset
  assets(after: AssetWhereUniqueInput, before: AssetWhereUniqueInput, first: Int, last: Int): [Asset!]!
  portfolio(where: PortfolioWhereUniqueInput!): Portfolio
  portfolios(after: PortfolioWhereUniqueInput, before: PortfolioWhereUniqueInput, first: Int, last: Int): [Portfolio!]!
  privateAsset(where: PrivateAssetWhereUniqueInput!): PrivateAsset
  privateAssets(after: PrivateAssetWhereUniqueInput, before: PrivateAssetWhereUniqueInput, first: Int, last: Int): [PrivateAsset!]!
  publicAsset(where: PublicAssetWhereUniqueInput!): PublicAsset
  publicAssets(after: PublicAssetWhereUniqueInput, before: PublicAssetWhereUniqueInput, first: Int, last: Int): [PublicAsset!]!
  user(where: UserWhereUniqueInput!): User
  users(after: UserWhereUniqueInput, before: UserWhereUniqueInput, first: Int, last: Int): [User!]!
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

type Transaction {
  asset: Asset!
  assetQuantity: Int!
  createdAt: DateTime!
  currency: String!
  date: DateTime!
  id: Int!
  note: String
  totalPrice: Int
  transactionType: TransactionType!
  unitPrice: Int!
  updatedAt: DateTime!
}

input TransactionCreateInput {
  asset: AssetCreateOneWithoutTransactionInput!
  assetQuantity: Int!
  createdAt: DateTime
  currency: String!
  date: DateTime
  note: String
  transactionType: TransactionType!
  unitPrice: Int!
  updatedAt: DateTime
}

input TransactionCreateManyWithoutAssetInput {
  connect: [TransactionWhereUniqueInput!]
  create: [TransactionCreateWithoutAssetInput!]
}

input TransactionCreateWithoutAssetInput {
  assetQuantity: Int!
  createdAt: DateTime
  currency: String!
  date: DateTime
  note: String
  transactionType: TransactionType!
  unitPrice: Int!
  updatedAt: DateTime
}

input TransactionFilter {
  every: TransactionWhereInput
  none: TransactionWhereInput
  some: TransactionWhereInput
}

input TransactionScalarWhereInput {
  AND: [TransactionScalarWhereInput!]
  assetId: IntFilter
  assetQuantity: IntFilter
  createdAt: DateTimeFilter
  currency: StringFilter
  date: DateTimeFilter
  id: IntFilter
  NOT: [TransactionScalarWhereInput!]
  note: NullableStringFilter
  OR: [TransactionScalarWhereInput!]
  transactionType: TransactionType
  unitPrice: IntFilter
  updatedAt: DateTimeFilter
}

enum TransactionType {
  buy
  sell
}

input TransactionUpdateManyDataInput {
  assetQuantity: Int
  createdAt: DateTime
  currency: String
  date: DateTime
  note: String
  transactionType: TransactionType
  unitPrice: Int
  updatedAt: DateTime
}

input TransactionUpdateManyWithoutAssetInput {
  connect: [TransactionWhereUniqueInput!]
  create: [TransactionCreateWithoutAssetInput!]
  delete: [TransactionWhereUniqueInput!]
  deleteMany: [TransactionScalarWhereInput!]
  disconnect: [TransactionWhereUniqueInput!]
  set: [TransactionWhereUniqueInput!]
  update: [TransactionUpdateWithWhereUniqueWithoutAssetInput!]
  updateMany: [TransactionUpdateManyWithWhereNestedInput!]
  upsert: [TransactionUpsertWithWhereUniqueWithoutAssetInput!]
}

input TransactionUpdateManyWithWhereNestedInput {
  data: TransactionUpdateManyDataInput!
  where: TransactionScalarWhereInput!
}

input TransactionUpdateWithoutAssetDataInput {
  assetQuantity: Int
  createdAt: DateTime
  currency: String
  date: DateTime
  note: String
  transactionType: TransactionType
  unitPrice: Int
  updatedAt: DateTime
}

input TransactionUpdateWithWhereUniqueWithoutAssetInput {
  data: TransactionUpdateWithoutAssetDataInput!
  where: TransactionWhereUniqueInput!
}

input TransactionUpsertWithWhereUniqueWithoutAssetInput {
  create: TransactionCreateWithoutAssetInput!
  update: TransactionUpdateWithoutAssetDataInput!
  where: TransactionWhereUniqueInput!
}

input TransactionWhereInput {
  AND: [TransactionWhereInput!]
  asset: AssetWhereInput
  assetId: IntFilter
  assetQuantity: IntFilter
  createdAt: DateTimeFilter
  currency: StringFilter
  date: DateTimeFilter
  id: IntFilter
  NOT: [TransactionWhereInput!]
  note: NullableStringFilter
  OR: [TransactionWhereInput!]
  transactionType: TransactionType
  unitPrice: IntFilter
  updatedAt: DateTimeFilter
}

input TransactionWhereUniqueInput {
  id: Int
}

type User {
  createdAt: DateTime!
  email: String!
  id: Int!
  name: String!
  updatedAt: DateTime!
}

input UserCreateInput {
  createdAt: DateTime
  email: String!
  name: String!
  password: String!
  portfolios: PortfolioCreateManyWithoutUserInput
  updatedAt: DateTime
}

input UserCreateOneWithoutPortfoliosInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutPortfoliosInput
}

input UserCreateWithoutPortfoliosInput {
  createdAt: DateTime
  email: String!
  name: String!
  password: String!
  updatedAt: DateTime
}

input UserUpdateInput {
  createdAt: DateTime
  email: String
  name: String
  password: String
  portfolios: PortfolioUpdateManyWithoutUserInput
  updatedAt: DateTime
}

input UserUpdateOneRequiredWithoutPortfoliosInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutPortfoliosInput
  update: UserUpdateWithoutPortfoliosDataInput
  upsert: UserUpsertWithoutPortfoliosInput
}

input UserUpdateWithoutPortfoliosDataInput {
  createdAt: DateTime
  email: String
  name: String
  password: String
  updatedAt: DateTime
}

input UserUpsertWithoutPortfoliosInput {
  create: UserCreateWithoutPortfoliosInput!
  update: UserUpdateWithoutPortfoliosDataInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  createdAt: DateTimeFilter
  email: StringFilter
  id: IntFilter
  name: StringFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  password: StringFilter
  portfolios: PortfolioFilter
  updatedAt: DateTimeFilter
}

input UserWhereUniqueInput {
  email: String
  id: Int
}
